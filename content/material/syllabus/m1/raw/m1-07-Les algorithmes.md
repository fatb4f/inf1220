Les algorithmes | INF 1220 - Introduction à la programmation 

[![Logo](/inf1220-hugo/livre.jpg)INF 1220 - Introduction à la programmation](/inf1220-hugo/)
--------------------------------------------------------------------------------------------

document.querySelector(".book-search").classList.remove("hidden")

*   [Programmation Java en ligne](/inf1220-hugo/docs/environnement/)
*   [Formattage du code Java](/inf1220-hugo/docs/format/)
*   [Vous avez trouvé une erreur?](/inf1220-hugo/docs/erreurs/)
*   [Modules](/inf1220-hugo/docs/modules/)
    *    [Module 1: Algorithme et pseudocode](/inf1220-hugo/docs/modules/module1/)
        *   [Modèle du cours](/inf1220-hugo/docs/modules/module1/teluq/)
        *   [Robot conversationnel et intelligence artificielle](/inf1220-hugo/docs/modules/module1/robot/)
        *   [Autoévaluation](/inf1220-hugo/docs/modules/module1/autoevaluation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module1/pasapas/)
        *   [Les ordinateurs et leurs langages](/inf1220-hugo/docs/modules/module1/ordinateurs/)
        *   [Les algorithmes](/inf1220-hugo/docs/modules/module1/algorithmes/)
        *   [Les algorithmes : conception et syntaxe](/inf1220-hugo/docs/modules/module1/algorithmes2/)
        *   [Les algorithmes: les structures de contrôle](/inf1220-hugo/docs/modules/module1/algorithmes3/)
        *   [Les problèmes difficiles](/inf1220-hugo/docs/modules/module1/difficile/)
        *   [Complexité algorithmique](/inf1220-hugo/docs/modules/module1/complex/)
        *   [Les erreurs communes](/inf1220-hugo/docs/modules/module1/erreurs/)
        *   [Présentation du pseudocode](/inf1220-hugo/docs/modules/module1/syntaxe/)
        *   [Exercices sur les algorithmes](/inf1220-hugo/docs/modules/module1/exercices/)
        *   [Travail noté 1](/inf1220-hugo/docs/modules/module1/travail-note-1/)
    *    [Module 2: Introduction au langage Java](/inf1220-hugo/docs/modules/module2/)
        *   [Préparation de l’espace de travail](/inf1220-hugo/docs/modules/module2/preparation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module2/pasapas/)
        *   [Création d'une classe en Java](/inf1220-hugo/docs/modules/module2/oriente/)
        *   [Introduction aux types de base et à leurs opérateurs](/inf1220-hugo/docs/modules/module2/typeoperateur/)
        *   [Exercices sur les classes, les variables, les types et les opérateurs](/inf1220-hugo/docs/modules/module2/exercices-2-1/)
        *   [Méthodes et constructeurs](/inf1220-hugo/docs/modules/module2/methodes/)
        *   [Exercices sur les classes et méthodes](/inf1220-hugo/docs/modules/module2/exercices-2-2/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module2/conseils/)
        *   [MarkDown](/inf1220-hugo/docs/modules/module2/markdown/)
        *   [Gabarit pour les travaux notés 2, 3, 4 et 5](/inf1220-hugo/docs/modules/module2/gabarit/)
        *   [Travail noté 2](/inf1220-hugo/docs/modules/module2/travail-note-2/)
    *    [Module 3: Les structures de données, de contrôle et d'itération en Java](/inf1220-hugo/docs/modules/module3/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module3/pasapas/)
        *   [GitHub](/inf1220-hugo/docs/modules/module3/github/)
        *   [Les structures de contrôle](/inf1220-hugo/docs/modules/module3/activite-3-1/)
        *   [Les structures itératives](/inf1220-hugo/docs/modules/module3/activite-3-2/)
        *   [Les chaînes de caractères (String)](/inf1220-hugo/docs/modules/module3/activite-3-3-string/)
        *   [Les structures de données de base](/inf1220-hugo/docs/modules/module3/activite-3-3/)
        *   [Les valeurs aléatoires](/inf1220-hugo/docs/modules/module3/activite-3-3-random/)
        *   [La programmation fonctionnelle en Java](/inf1220-hugo/docs/modules/module3/fonctionnel/)
        *   [Exercices sur les structures de contrôle, les structures de données, les structures itératives](/inf1220-hugo/docs/modules/module3/exercices-3-1/)
        *   [Les exceptions](/inf1220-hugo/docs/modules/module3/activite-3-4/)
        *   [La récursivité](/inf1220-hugo/docs/modules/module3/activite-3-5/)
        *   [Exercices sur les exceptions et la récursivité](/inf1220-hugo/docs/modules/module3/exercices-3-2/)
        *   [Exemple : modèle de langue](/inf1220-hugo/docs/modules/module3/activite-3-3-modele/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module3/conseils/)
        *   [Travail noté 3](/inf1220-hugo/docs/modules/module3/travail-note-3/)
    *    [Module 4: Les entrées et sorties](/inf1220-hugo/docs/modules/module4/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module4/pasapas/)
        *   [Les flux de console](/inf1220-hugo/docs/modules/module4/activite-4-1/)
        *   [Les flux de données: lecture dans des fichiers et autres](/inf1220-hugo/docs/modules/module4/activite-4-2/)
        *   [Exercices sur les flux](/inf1220-hugo/docs/modules/module4/exercices-4-1/)
        *   [Développement web](/inf1220-hugo/docs/modules/module4/web/)
        *   [Travail noté 4](/inf1220-hugo/docs/modules/module4/travail-note-4/)
    *    [Module 5. La programmation orientée objet: héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module5/pasapas/)
        *   [L'héritage, les classes abstraites et les interfaces](/inf1220-hugo/docs/modules/module5/activite-5-1/)
        *   [Le polymorphisme](/inf1220-hugo/docs/modules/module5/activite-5-2/)
        *   [Exercices sur l’héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/exercices-5-1/)
        *   [Travail noté 5](/inf1220-hugo/docs/modules/module5/travail-note-5/)
    *   [Examen](/inf1220-hugo/docs/modules/examen/)
*   [Évaluation](/inf1220-hugo/docs/evaluation/)
*   [Pense-bête java](/inf1220-hugo/docs/pensebete/)
*    Autres ressources
    *   [Le professeur](/inf1220-hugo/docs/extra/credits/)
    *   [Feuille de route](/inf1220-hugo/docs/extra/feuille-de-route/)
    *   [Ressources](/inf1220-hugo/docs/extra/ressources/)
    *   [FAQ](/inf1220-hugo/docs/extra/faq/)
    *   [Manuel](/inf1220-hugo/docs/extra/manuel/)
    *   [Rappel mathématique](/inf1220-hugo/docs/extra/math/)
    *   [Intelligence artificielle](/inf1220-hugo/docs/extra/ia/)
    *   [Petit guide d’usage du courriel efficace](/inf1220-hugo/docs/extra/courriel/)

(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()

![Menu](/inf1220-hugo/svg/menu.svg)

### Les algorithmes

![Table of Contents](/inf1220-hugo/svg/toc.svg)

*   [Préalables](#préalables)
*   [Introduction](#introduction)
    *   [Qu’est-ce qu’un algorithme ?](#quest-ce-quun-algorithme-)
    *   [Qu’est-ce que le pseudo-code ?](#quest-ce-que-le-pseudo-code-)
    *   [Variables et valeurs](#variables-et-valeurs)
    *   [Logique booléenne](#logique-booléenne)
    *   [Notation des programmeurs](#notation-des-programmeurs)
*   [La boucle](#la-boucle)
*   [Tableau](#tableau)
*   [Exemple : Calcul de la moyenne](#exemple--calcul-de-la-moyenne)

Les algorithmes [#](#les-algorithmes)
=====================================

> _The etymology of program is pro ‘before’ + graphein ‘write’. I think of programming as making a plan that will be executed in the future, something that every human does from time to time. The hard part is that a computer has to execute the plan, and computers are incredibly stupid. Dealing with such stupidity requires more patience and determination than many people have._ (Peter Turney)

> Préalables [#](#pr%c3%a9alables)
> --------------------------------
> 
> Dans ce cours, nous présentons les notions de manière exhaustive, avec beaucoup d’exemples et des activités d’approfondissement. Néanmoins, nous supposons dans ce cours que vous avez complété les mathématiques du collégial et que vous avez de bonnes aptitudes en ce qui a trait aux raisonnements formels. Dans ce premier module, vous aurez à exprimer la solution de certains problèmes en terme de variables, de boucles et d’embranchement. Il ne s’agit pas de notions avancées : vous devriez être familier avec ces notions. Les boucles font partie implicitement du calcul d’une somme ou d’un produit scalaire. Les variables en informatique sont une notion voisine des variables en algèbre. Les embranchements sont des notions de base en logique élémentaire. Nous supposons une familiarité avec ces notions. Vous êtes responsables de vous assurez que vous avez la préparation nécessaire pour suivre le cours INF 1220.

Introduction [#](#introduction)
-------------------------------

Le processus systématique de résolution d’un problème donné s’appelle algorithme. La notion d’algorithme formel est vue dans le cadre des cours de mathématiques du secondaire, notamment dans le contexte de [la théorie des graphes](https://www.alloprof.qc.ca/fr/eleves/bv/mathematiques/la-chaine-de-poids-minimal-m1010) et des algorithmes d’optimisation. Comme point de départ dans le cours INF 1220, nous revisitons et approfondissons brièvement cette notion fondamentale.

Un algorithme est donc une suite d’actions pour répondre à un problème de traitement de l’information. Ces actions peuvent être mathématiques (ex. somme = a + b), de contrôles (ex. SI a > b ALORS) ou d’itérations (ex. TANT QUE a > b FAIRE). Pour décrire ces algorithmes, il existe également plusieurs formalismes, certains utiliseront des formalismes mathématiques alors que d’autres utiliseront des pseudo-codes. Encore là dans plusieurs formats pour représenter un pseudo-code, il n’existe pas de normes uniques!

En cuisine, une recette est un exemple d’algorithme si celle-ci comporte une séquence d’instructions précises. Pouvoir rédiger de manière précise une recette afin que d’autres cuisiniers puissent reproduire la même séquence d’opération est de facto de la programmation informatique. Si vous avez fait l’expérience du manuel de recette de quelqu’un d’autre (par ex., votre grand-mère), vous avez peut-être découvert qu’il peut être difficile de suivre des consignes de quelqu’un d’autre surtout quand celles-ci ne sont pas suffisamment précises. Une recette de cuisine est du pseudo-code.

Avant l’invention du GPS, il était commun d’expliquer à des amis ou des parents comment se rendre à un lieu donné en suivant une série d’instructions. Il arrivait souvent, malheureusement, que ces instructions n’étaient pas assez précises et que les gens se perdent. Expliquer à quelqu’un comment se rendre à un lieu donné est un exemple de programmation informatique. Votre explication est du pseudo-code.

Il est essentiel de comprendre ce qu’est le pseudo-code: il s’agit d’une façon de décrire un algorithme afin que d’autres êtres humains puissent vous comprendre. Il faut donc interpréter le pseudo-code en utilisant son jugement humain de la même façon que vous interprétez tout autre texte ou discours. Pouvoir lire un algorithme, décrit en pseudo-code, est une compétence essentielle en informatique. Il faut être capable de comprendre d’autres informaticiens sans nécessairement exiger que ceux-ci utilisent du code informatique dans un langage particulier (par ex., Java). Programmer et faire de l’informatique exige de pouvoir bien communiquer avec les autres informaticiens indépendamment de langages de programmation spécifiques.

Pour un programmeur d’expérience, s’exprimer à l’aide d’un pseudo-code est chose aisée. Pour le commun des mortels, c’est un peu plus difficile. La blague suivante illustre le problème.

> Une femme demande à son programmeur de mari : « Va au supermarché acheter une bouteille de lait. Et si ils ont des œufs, prends en 6 ». Le mari revient avec six bouteilles de lait. Sa femme lui demande pourquoi il a pris six bouteilles. « Parce qu’ils avaient des oeufs » répond-il.

Quand on rédige un pseudo-code, il faut tout spécifier, comme si on s’adressait à quelqu’un qui prend tout littéralement, sans aucun jugement. Pour devenir un programmeur, pour penser comme un programmeur, il faut s’habituer à rédiger des séquences d’instructions précises. La lecture et la rédaction de pseudo-codes relativement simples peut être une bonne pratique.

Le pseudocode est destiné à être lu par l’humain, et il peut être écrit de diverses manières tant que l’humain le comprend. Le cours ne vise pas à vous permettre de comprendre une syntaxe particulière de pseudocode, mais bien le pseudocode en général.

### Qu’est-ce qu’un algorithme ? [#](#quest-ce-quun-algorithme-)

Un _algorithme_ est une suite finie et ordonnée d’instructions permettant de résoudre un problème ou d’accomplir une tâche spécifique. Il s’agit d’une méthode systématique, exprimée de manière précise, qui garantit un résultat correct lorsqu’elle est exécutée. Les algorithmes sont au cœur de l’informatique, car ils décrivent comment un programme doit fonctionner pour atteindre un objectif.

Exemples d’algorithmes dans la vie quotidienne :

*   Une recette de cuisine (série d’étapes pour préparer un plat).
*   Les instructions pour assembler un meuble.

En informatique, un algorithme peut, par exemple, trier une liste de nombres ou calculer le chemin le plus court entre deux points.

### Qu’est-ce que le pseudo-code ? [#](#quest-ce-que-le-pseudo-code-)

Le _pseudo-code_ est une manière d’écrire un algorithme en utilisant un langage simplifié, proche du langage naturel, mais structuré comme un programme informatique. Il n’est pas destiné à être exécuté directement par un ordinateur, mais sert à décrire la logique d’un algorithme de manière claire et compréhensible, indépendamment d’un langage de programmation spécifique.

Le pseudo-code utilise des conventions comme :

*   `SI`, `ALORS`, `SINON` pour les conditions.
*   `POUR`, `TANT QUE` pour les boucles.
*   Des instructions comme `écrire` ou `lire` pour les entrées/sorties.

Exemple de pseudo-code pour calculer la somme de deux nombres :

    lire nombre1
    lire nombre2
    somme ← nombre1 + nombre2
    écrire somme
    

Le pseudo-code permet aux programmeurs de planifier la logique avant de la traduire dans un langage comme Python, C++ ou Java.

En résumé, un algorithme est une méthode pour résoudre un problème, tandis que le pseudo-code est un outil pour exprimer cet algorithme de manière claire et universelle. Ces deux concepts sont essentiels pour concevoir des solutions informatiques efficaces.

### Variables et valeurs [#](#variables-et-valeurs)

Une _variable_ en informatique est un espace de stockage nommé qui contient une valeur. Elle peut être vue comme une boîte étiquetée dans laquelle on place une donnée, et cette donnée peut changer au cours de l’exécution d’un algorithme. Les variables permettent de manipuler des informations de manière dynamique, en les stockant temporairement pour les utiliser ou les modifier plus tard.

Les variables peuvent contenir différents types de données, selon leur nature et leur usage. Les types courants incluent :

*   **Entier** : un nombre sans partie décimale, comme 5, -12 ou 0.
*   **Réel** : un nombre avec une partie décimale, comme 3.14, -0.001 ou 10.4.
*   **Booléen** : une valeur logique qui peut être soit vrai, soit faux.
*   **Chaîne de caractères** : une séquence de caractères, comme “bonjour” ou “INF1220”.

Dans le pseudo-code, le type de la variable est souvent implicite, mais il est essentiel de comprendre quel type de donnée une variable contient pour éviter des erreurs lors de la manipulation. Une variable doit être _nommée_ de manière claire et descriptive (par exemple, `age`, `somme`, `notes`). On lui attribue une valeur à l’aide de l’opérateur d’affectation, souvent représenté par `←` ou `=`. Par exemple :

    age ← 18
    somme ← 0
    

Ici, la variable `age` reçoit la valeur entière 18, et `somme` reçoit la valeur entière 0.

Considérons un algorithme simple qui calcule le carré d’un nombre entré par l’utilisateur :

    lire nombre
    carre ← nombre * nombre
    écrire carre
    

Dans cet exemple :

*   `nombre` est une variable qui stocke la valeur entrée (par exemple, un réel comme 4.5).
*   `carre` est une variable qui stocke le résultat de l’opération `nombre * nombre` (par exemple, 20.25 si `nombre` vaut 4.5).
*   L’instruction `écrire carre` affiche la valeur de la variable `carre`.

Chaque variable doit avoir un nom distinct dans un algorithme pour éviter toute confusion. Il est recommandé d’initialiser une variable (lui donner une valeur de départ) avant de l’utiliser, pour éviter des comportements imprévisibles. Par exemple, avant d’additionner des nombres dans une variable `somme`, on écrit souvent `somme ← 0`. Certaines variables ont une une portée et elles ne sont accessibles que dans la partie de l’algorithme où elles sont définies. Par exemple, nous nous pouvons utiliser la valeur de la variable `somme` avant de lui avoir assigné une valeur (`somme ← 0`).

Les variables sont essentielles pour écrire des algorithmes flexibles et réutilisables. Elles permettent de travailler avec des données qui varient, comme des entrées utilisateur ou des résultats intermédiaires, et de suivre l’état d’un algorithme tout au long de son exécution. En pseudo-code, les variables servent à rendre les instructions claires et compréhensibles, tout en préparant la transition vers un langage de programmation réel.

Pour illustrer simplement la déclaration et l’affectation d’une variable, voici comment on déclare une variable nommée `age` et on lui assigne la valeur 18 dans différents langages.

En Java, la déclaration exige de préciser le type :

    int age = 18;  // déclaration et affectation en une seule ligne
    

En JavaScript, le type est inféré automatiquement :

    let age = 18;  // déclaration et affectation
    

En Go, on peut utiliser la déclaration courte quand le type est évident :

    age := 18  // déclaration et affectation, type int inféré
    

Ou de manière plus explicite :

    var age int = 18
    

En C++, le type doit aussi être indiqué explicitement :

    int age = 18;  // déclaration et affectation
    

Ces lignes montrent la forme la plus basique de création et d’initialisation d’une variable, équivalente à l’instruction `age ← 18` du pseudo-code. La syntaxe varie légèrement selon le langage, mais le principe reste identique : nommer un espace mémoire et y placer une valeur.

### Logique booléenne [#](#logique-bool%c3%a9enne)

Un des fondements des algorithmes est la logique booléenne. Elle permet de manipuler des valeurs logiques, appelées booléennes, qui ne peuvent prendre que deux états : vrai ou faux. Ces valeurs sont utilisées pour prendre des décisions, contrôler le flux d’un algorithme ou évaluer des conditions dans des structures comme les boucles et les embranchements.

Les principaux opérateurs booléens sont décrits ci-dessous, accompagnés de leur table de vérité, qui montre le résultat de chaque opération pour toutes les combinaisons possibles des entrées A et B.

A

B

NON A

A ET B

A OU B

vrai

vrai

faux

vrai

vrai

vrai

faux

faux

faux

vrai

faux

vrai

vrai

faux

vrai

faux

faux

vrai

faux

faux

*   **NON A** : l’inverse de A (négation)
*   **A ET B** : vrai seulement si A et B sont vrais
*   **A OU B** : vrai si au moins un des deux est vrai

En informatique, nous utilisons le plus souvent l’anglais.

*   **NON A** : **NOT A**
*   **A ET B** : **A AND B**
*   **A OU B** : **A OR B**

#### Exemple 1 : Contrôle d’accès selon l’âge [#](#exemple-1--contr%c3%b4le-dacc%c3%a8s-selon-l%c3%a2ge)

    lire age
    SI age >= 18 ALORS
        écrire "Accès autorisé"
    SINON
        écrire "Accès refusé"
    FIN SI
    

Ce pseudocode décrit un algorithme simple de contrôle d’accès basé sur l’âge d’une personne. L’instruction lire age récupère une valeur (l’âge) entrée par l’utilisateur ou une source externe, stockée dans la variable age. Une structure conditionnelle (SI … ALORS … SINON) vérifie si age est supérieur ou égal à 18. Si la condition est vraie (age >= 18), l’algorithme affiche le message “Accès autorisé”, indiquant que la personne est majeure et peut accéder à une ressource ou un lieu. Sinon, si age est inférieur à 18, il affiche “Accès refusé”, signalant que l’accès est interdit. L’algorithme se termine après l’affichage.

La logique booléenne est essentielle pour écrire des conditions dans les algorithmes. Par exemple, dans une structure conditionnelle ou une boucle, les opérateurs booléens permettent de combiner plusieurs critères. Voici un exemple en pseudo-code pour vérifier si une personne peut voter :

    lire age
    lire est_citoyen
    SI age >= 19 ET est_citoyen = vrai ALORS
        écrire "Vous pouvez voter"
    SINON
        écrire "Vous ne pouvez pas voter"
    FIN SI
    

Ici, la condition `age >= 19 ET est_citoyen = vrai` utilise l’opérateur ET pour vérifier que deux critères sont remplis avant d’autoriser le vote.

Lorsqu’on combine plusieurs opérateurs booléens, il est important de connaître leur ordre de priorité :

1.  **NON** (évalué en premier).
2.  **ET**.
3.  **OU** (évalué en dernier). Pour éviter toute ambiguïté, on utilise des parenthèses pour préciser l’ordre des opérations. Par exemple :

    vrai ET faux OU vrai
    

Sans parenthèses, ET est évalué avant OU, donc cela donne `(vrai ET faux) OU vrai`, qui vaut `faux OU vrai`, soit `vrai`. Avec des parenthèses, on peut changer le résultat : `vrai ET (faux OU vrai)` donne `vrai ET vrai`, soit `vrai`.

Pour renforcer votre compréhension, utilisez l’application suivante.

Points : 0 | Vies : 5

Expression : TRUE AND FALSE

Démarrer le jeu Gauche Droite Tirer

(function(){const n="logicalGame\_",s=document.getElementById(\`${n}gameCanvas\`),t=s.getContext("2d"),C=document.getElementById(\`${n}score\`),\_=document.getElementById(\`${n}lives\`),N=document.getElementById(\`${n}expression\`),m=document.getElementById(\`${n}startButton\`),D=document.getElementById(\`${n}leftButton\`),T=document.getElementById(\`${n}rightButton\`),k=document.getElementById(\`${n}shootButton\`),a=document.getElementById(\`${n}feedbackMessage\`),u=document.getElementById(\`${n}gameOver\`),g=document.getElementById(\`${n}shootSound\`),p=document.getElementById(\`${n}correctSound\`),y=document.getElementById(\`${n}incorrectSound\`);let r=0,l=5,h=!1,e={x:s.width/2-25,y:550,width:50,height:30,speed:5},o=\[\],i=\[\],c=\[\],w={p:!0,q:!1,result:!1,text:"TRUE AND FALSE"},O=0,x=0;const F=200;function E(e,t){a.textContent=e,a.style.display="block",a.style.backgroundColor=t?"rgba(144, 238, 144, 0.9)":"rgba(255, 99, 71, 0.9)",a.style.color=t?"#006400":"#8B0000";const n=s.getBoundingClientRect(),o=s.parentElement.getBoundingClientRect();a.style.left=\`${n.left-o.left+n.width/2}px\`,a.style.top=\`${n.top-o.top+n.height/2}px\`,setTimeout(()=>{a.style.display="none"},1500)}function S(e,t){c.push({x:e,y:t,radius:5,maxRadius:40,opacity:1,color:"orange"})}function A(){for(let n=c.length-1;n>=0;n--){let e=c\[n\];t.beginPath(),t.arc(e.x,e.y,e.radius,0,Math.PI\*2),t.fillStyle=\`rgba(255, 165, 0, ${e.opacity})\`,t.fill(),e.radius+=3,e.opacity-=.07,e.opacity<=0&&c.splice(n,1)}}function j(){const o=\["AND","OR","XOR"\],e=Math.random()>.5,t=Math.random()>.5,s=o\[Math.floor(Math.random()\*o.length)\];let n,i=\`${String(e).toUpperCase()} ${s} ${String(t).toUpperCase()}\`;s==="AND"?n=e&&t:s==="OR"?n=e||t:n=(e||t)&&!(e&&t),w={p:e,q:t,result:n,text:i},N.textContent=\`Expression : ${i}\`}function M(){const e=Math.random()>.5,t=Math.random()\*(s.width-50);o.push({x:t,y:0,width:50,height:40,value:e,speed:2})}function d(t){t==="left"&&e.x>0&&(e.x-=e.speed),t==="right"&&e.x<s.width-e.width&&(e.x+=e.speed)}function v(){const t=Date.now();t-x>F&&(i.push({x:e.x+e.width/2-2.5,y:e.y,width:5,height:10,speed:7}),g.currentTime=0,g.play(),x=t)}function z(e,t){return e.x<t.x+t.width&&e.x+e.width>t.x&&e.y<t.y+t.height&&e.y+e.height>t.y}function b(){if(!h)return;t.clearRect(0,0,s.width,s.height),t.fillStyle="blue",t.fillRect(e.x,e.y,e.width,e.height),Date.now()-O>1e3&&(M(),O=Date.now()),o=o.filter(e=>e.y<s.height),o.forEach(e=>{e.y+=e.speed,t.fillStyle=e.value?"green":"red",t.fillRect(e.x,e.y,e.width,e.height),t.fillStyle="white",t.font="16px Arial",t.textAlign="center",t.fillText(String(e.value).toUpperCase(),e.x+e.width/2,e.y+e.height/2+5)}),i=i.filter(e=>e.y>0),i.forEach(e=>{e.y-=e.speed,t.fillStyle="black",t.fillRect(e.x,e.y,e.width,e.height)});for(let e=i.length-1;e>=0;e--){const t=i\[e\];for(let s=o.length-1;s>=0;s--){const n=o\[s\];if(z(t,n)){S(n.x+n.width/2,n.y+n.height/2),i.splice(e,1),o.splice(s,1),n.value===w.result?(r+=10,C.textContent=r,p.currentTime=0,p.play(),E("Bonne réponse !",!0),j()):(l-=1,\_.textContent=l,y.currentTime=0,y.play(),E("Mauvaise réponse !",!1),l<=0&&(h=!1,u.textContent=\`Partie terminée ! Points : ${r} Cliquez pour recommencer\`,u.style.display="block",u.onclick=f));break}}}A(),requestAnimationFrame(b)}function f(){h=!0,r=0,l=5,o=\[\],i=\[\],c=\[\],e.x=s.width/2-e.width/2,C.textContent=r,\_.textContent=l,j(),m.textContent="Jeu en cours",u.style.display="none",b()}m.addEventListener("click",f),D.addEventListener("click",()=>d("left")),T.addEventListener("click",()=>d("right")),k.addEventListener("click",v),document.addEventListener("keydown",e=>{e.key==="ArrowLeft"&&d("left"),e.key==="ArrowRight"&&d("right"),e.key===" "&&v()})})()

En maîtrisant la logique booléenne, vous serez mieux équipé pour concevoir des algorithmes clairs et efficaces, en particulier lorsqu’il s’agit de prendre des décisions complexes basées sur plusieurs conditions.

#### Exemple 2 : Vérifier si un nombre est dans un intervalle [#](#exemple-2--v%c3%a9rifier-si-un-nombre-est-dans-un-intervalle)

    lire x
    SI x >= 10 ET x <= 20 ALORS
        écrire "x est dans l'intervalle [10, 20]"
    SINON
        écrire "x n'est pas dans l'intervalle"
    FIN SI
    

Ce pseudocode décrit un algorithme qui vérifie si une valeur entrée se situe dans l’intervalle fermé \[10, 20\]. L’instruction lire x récupère une valeur (un nombre, supposé réel ou entier) entrée par l’utilisateur, stockée dans la variable x. Une structure conditionnelle (SI … ALORS … SINON) évalue si x satisfait deux conditions combinées par l’opérateur ET : x >= 10 (x est supérieur ou égal à 10) et x <= 20 (x est inférieur ou égal à 20). Si les deux conditions sont vraies, c’est-à-dire si x est dans l’intervalle \[10, 20\], l’algorithme affiche “x est dans l’intervalle \[10, 20\]”. Sinon, si x est inférieur à 10 ou supérieur à 20, il affiche “x n’est pas dans l’intervalle”. L’algorithme se termine après l’affichage.

mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})

graph TD
    A\[Lire x\] --> B{x >= 10 ET x <= 20 ?}
    B -- Vrai --> C\["x est dans l'intervalle"\]
    B -- Faux --> D\["x n'est pas dans l'intervalle"\]
    C --> E\[Fin\]
    D --> E
  

### Notation des programmeurs [#](#notation-des-programmeurs)

Pour des raisons historiques, les programmeurs remplacent souvent ET par `&&`, OU par `||` et NON par `!`. C’est le cas notamment en Java.

Utilisez l’application suivante pour tester votre compréhension.

Calculateur d'expressions booléennes
====================================

Sélectionner ou entrer une expression Choisir un exemple...!A || AA && BA || B!A && BA || !B!(A && B)(A || B) && !A

Générer la table de vérité

(function(){const e={operators:{"!":{precedence:3,type:"unary"},"&&":{precedence:2,type:"binary"},"||":{precedence:1,type:"binary"}},tokenizeExpression(e){const n=\[\],s=/(!|&&|\\|\\||\\(|\\))|(\[AB\])/g;let t;for(;(t=s.exec(e))!==null;)t\[1\]?n.push(t\[1\]):t\[2\]&&n.push(t\[2\]);return n},toRPN(e){if(!e||typeof e!="string")return\[\];const s=this.tokenizeExpression(e.replace(/\\s+/g,"")),n=\[\],t=\[\];for(const e of s)if(e==="A"||e==="B")n.push(e);else if(e==="(")t.push(e);else if(e===")"){for(;t.length>0&&t\[t.length-1\]!=="(";)n.push(t.pop());if(t.length===0||t\[t.length-1\]!=="(")throw new Error("Parenthèses mal assorties.");t.pop()}else if(this.operators\[e\]){for(;t.length>0&&t\[t.length-1\]!=="("&&this.operators\[t\[t.length-1\]\]&&this.operators\[t\[t.length-1\]\].precedence>=this.operators\[e\].precedence;)n.push(t.pop());t.push(e)}for(;t.length>0;){const e=t.pop();if(e==="("||e===")")throw new Error("Parenthèses mal assorties.");n.push(e)}return n},evaluateRPN(e,t){const n=\[\];for(const s of e)if(s==="A")n.push(t.A);else if(s==="B")n.push(t.B);else if(this.operators\[s\])if(this.operators\[s\].type==="unary"){if(n.length<1)throw new Error(\`Opérandes insuffisants pour l'opérateur '${s}'.\`);const e=n.pop();s==="!"&&n.push(!e)}else{if(n.length<2)throw new Error(\`Opérandes insuffisants pour l'opérateur '${s}'.\`);const e=n.pop(),t=n.pop();s==="&&"?n.push(t&&e):s==="||"&&n.push(t||e)}if(n.length!==1)throw new Error("Expression mal formée.");return n\[0\]},generateTruthTable(e){if(!e||!e.trim())return'<div style="color: #dc2626;">Erreur : veuillez entrer une expression valide.</div>';let n;try{n=this.toRPN(e)}catch(e){return\`<div style="color: #dc2626;">Erreur de l'expression : ${e.message}</div>\`}const s=\[{A:!0,B:!0},{A:!0,B:!1},{A:!1,B:!0},{A:!1,B:!1}\];let t='<h2 style="font-size: 20px; font-weight: bold; margin-bottom: 12px;">Tableau de vérité pour : '+e+"</h2>";return t+='<table style="width: 100%; border-collapse: collapse; margin-top: 8px;">',t+="<thead>",t+='<tr style="background-color: #e5e7eb;">',t+='<th style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">A</th>',t+='<th style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">B</th>',t+='<th style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">Résultat</th>',t+="</tr>",t+="</thead>",t+="<tbody>",s.forEach((e,s)=>{let o;try{o=this.evaluateRPN(n,e)}catch(e){return\`<div style="color: #dc2626;">Erreur d'évaluation : ${e.message}</div>\`}t+=\`<tr id="boolcalc-row-${s}" style="opacity: 0; transition: opacity 0.5s ease, background-color 0.5s ease;">\`,t+=\`<td style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">${e.A?"vrai":"faux"}</td>\`,t+=\`<td style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">${e.B?"vrai":"faux"}</td>\`,t+=\`<td style="border: 1px solid #d1d5db; padding: 8px; text-align: center;">${o?"vrai":"faux"}</td>\`,t+="</tr>"}),t+="</tbody>",t+="</table>",{html:t,rowCount:s.length}},animateRows(e){for(let t=0;t<e;t++)setTimeout(()=>{const e=document.getElementById(\`boolcalc-row-${t}\`);e&&(e.style.opacity="1",e.style.backgroundColor="#bfdbfe",setTimeout(()=>{e.style.backgroundColor="transparent"},1e3))},t\*1e3)},init(){const e=document.getElementById("expression"),n=document.getElementById("customExpression"),s=document.getElementById("calculate"),t=document.getElementById("result");if(!e||!n||!s||!t){console.error("Erreur : un ou plusieurs éléments DOM sont manquants."),t.innerHTML=\`<div style="color: #dc2626;">Erreur : échec de l'initialisation de l'application.</div>\`;return}e.addEventListener("change",()=>{n.value=e.value,t.innerHTML=""}),s.addEventListener("click",()=>{const o=n.value.trim()||e.value.trim(),s=this.generateTruthTable(o);typeof s=="string"?t.innerHTML=s:(t.innerHTML=s.html,this.animateRows(s.rowCount))}),e.value&&(n.value=e.value)}};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",()=>e.init()):e.init()})()

La boucle [#](#la-boucle)
-------------------------

Un algorithme prend habituellement des données et produit un résultat. Par exemple, un algorithme cherchant à déterminer si un nombre est pair, pourra recevoir un nombre en paramètre et il pourra produire comme réponse une valeur booléenne (vrai ou faux). Un même algorithme va donc généralement pouvoir être exécuté sur différentes données et pouvoir fournir des réponses différentes. En ce sens, une fonction (au sens mathématique) comme f(x) = a x + b peut être décrite comme étant un algorithme. Une fonction doit toujours produire la même valeur étant donnée les mêmes données. Un algorithme n’est pas limité de cette manière. Par exemple, un algorithme pourrait servir à choisir un nom aléatoirement au sein d’une liste. D’une exécution à l’autre, l’algorithme pourrait produire des valeurs différentes avec les mêmes données.

La plupart des algorithmes en pratique sont itératifs. Une itération est la répétition d’un processus. Si vous devez teindre une clôture, vous allez peut-être teindre chaque planche une à une. Nous dirons alors que vous itérez sur les planches. Mais comment saurez-vous où vous êtes rendu si vous prenez une pause? Peut-être pourrez-vous poser un petit drapeau sur la planche que vous êtes en train de teindre. On dira alors que le drapeau est un itérateur, c’est-à-dire un indicateur de votre progrès dans votre itération. À chaque étape où vous déplacez le drapeau d’une planche à l’autre, nous pourrons dire que vous incrémentez la position du drapeau. Si jamais vous deviez faire un retour à la planche précédente, nous dirons que vous décrémentez le drapeau. En informatique, nous n’utilisons pas de drapeaux physiques. Pour savoir où on est rendu, on utilise des compteurs, le plus souvent des valeurs entières. Quand on dit qu’on incrémente un entier, on veut généralement dire qu’on ajoute “1” à sa valeur.

Nous obtenons alors la notion de boucle: nous effectuons une tâche donnée tant qu’une condition n’est pas satisfaite. Cette vidéo présente le concept de boucle.

En informatique, on fait souvent référence à la notion d’impression à l’écran. Le plus souvent cela fait référence à l’affichage à l’écran d’un message ou d’un texte.

Pour illustrer concrètement ces concepts, considérons un exemple simple : afficher les nombres de 1 à 10 à l’écran, en utilisant une boucle qui incrémente un compteur à chaque itération. Cela montre comment un compteur agit comme un itérateur et comment la boucle répète l’impression jusqu’à ce que la condition soit satisfaite.

En Java, une boucle for classique s’écrit ainsi :

    for (int i = 1; i <= 10; i++) {
        System.out.println(i);
    }
    

Ici, i est initialisé à 1, la boucle continue tant que i est inférieur ou égal à 10, et i est incrémenté de 1 à chaque tour.

En JavaScript, la syntaxe est très similaire :

    for (let i = 1; i <= 10; i++) {
        console.log(i);
    }
    

La différence principale réside dans l’utilisation de let pour déclarer la variable i, ce qui limite sa portée à la boucle.

En Go, on utilise également une boucle for (la seule structure de boucle disponible dans le langage) :

    for i := 1; i <= 10; i++ {
        fmt.Println(i)
    }
    

L’initialisation, la condition et l’incrémentation sont regroupées dans l’en-tête de la boucle, comme dans les langages précédents.

En C++, la boucle for prend une forme proche de celle de Java :

    #include <iostream>
    
    for (int i = 1; i <= 10; i++) {
        std::cout << i << std::endl;
    }
    

Ces exemples montrent à quel point le concept de boucle avec compteur est universel dans les langages impératifs, même si les syntaxes varient légèrement. Dans tous les cas, l’impression à l’écran (via println, console.log, fmt.Println ou cout) est répétée 10 fois, en incrémentant l’itérateur à chaque passage. Cet usage évite d’écrire manuellement dix instructions d’impression identiques, rendant le code plus concis et plus facile à modifier (par exemple, pour changer la borne supérieure).

Tableau [#](#tableau)
---------------------

Un tableau est une structure de données qui permet de stocker plusieurs éléments, comme des nombres ou des chaînes de caractères, dans une seule variable. Ces éléments sont organisés séquentiellement et accessibles via un indice, un nombre entier qui indique leur position. Par exemple, dans un tableau nommé tableau, l’élément à la position 1 est noté `tableau[1]`, celui à la position 2 est `tableau[2]`, et ainsi de suite. La taille du tableau est normalement fixée et connue.

La numérotation des indices varie selon les langages de programmation ou les contextes. Dans de nombreux langages comme C, Java ou Python, les indices commencent à 0 : le premier élément est `tableau[0]`, le deuxième `tableau[1]`, etc. Cette convention, dite « base 0 », est courante en informatique pour des raisons techniques liées à la gestion de la mémoire. Dans d’autres contextes, comme certaines notations mathématiques ou langages comme Lua, les indices débutent à 1, ce qui peut être plus intuitif pour des utilisateurs non techniques. Le choix de l’index de départ dépend donc du système utilisé, et il est crucial de connaître cette convention pour manipuler correctement les éléments d’un tableau. La convention utilisée est souvent claire selon le contexte.

Tous les langages de programmation supportent les tableaux.

En Java, nous pouvons créer un tableau d’entiers comprenant 5 éléments comme suit.

    int [] tableau = new int[5];
    

Dans ce cas, le tableau comprendra la valeur 0 répétée 5 fois. Nous pouvons aussi initialiser un tableau avec les entiers `1,2,3` comme suit.

    int [] tableau = [1,2,3];
    

En JavaScript, la syntaxe équivalente est celle-ci.

    let tableau = Array(5).fill(0);
    let tableau = [1, 2, 3];
    

En Go, nous utiliserions la syntaxe suivante.

    tableau := make([]int, 5)
    tableau := []int{1, 2, 3}
    

En C++, nous pourrions faire l’équivalent.

    int tableau[5]{};
    int tableau[]{1, 2, 3};
    

Dans tous ces langages, l’expression `tableau[0]` fait référence au premier élément du tableau.

Exemple : Calcul de la moyenne [#](#exemple--calcul-de-la-moyenne)
------------------------------------------------------------------

Pour illustrer la notion de pseudo-code, commençons par un exemple relativement simple. Supposons que nous avons un tableau de notes (par ex., les notes 10.4, 12.6, 18.7, 5.0) et que nous désirons calculer la moyenne. On utilise le convention que si le tableau se nomme ’notes’, alors la première note (par ex., 10.4) est notes\[0\], la seconde note est notes\[1\]… et ainsi de suite jusqu’à notes\[3\]. Évidemment, dans ce cas, on sait qu’il y’a 4 notes, mais il plus pratique d’écrire le pseudo-code de manière générale. On fera donc référence à la longueur du tableau (au nombre d’éléments qu’il contient) comme étant un paramètre. Pour visiter tous les éléments, on peut initialiser une valeur entière à 0, et l’incrémenter de 1 tant qu’elle demeure plus petite que la longueur du tableau.

graph TD
    A\[Début\] --> B\[Initialiser iterateur = 0, moyenne = 0\]
    B --> C{iterateur < longueur de notes ?}
    C -- Vrai --> D\["moyenne = moyenne + notes\[iterateur\]"\]
    D --> E\[iterateur = iterateur + 1\]
    E --> C
    C -- Faux --> F\[moyenne = moyenne / longueur de notes\]
    F --> G\[Afficher moyenne\]
    G --> H\[Fin\]

Utilisez l’application suivante pour explorer l’exécution de l’algorithme. Ce pseudocode calcule la moyenne de quatre nombres rationnels stockés dans un tableau notes. Une variable iterateur est initialisée à 0 pour parcourir le tableau, et une variable moyenne est initialisée à 0 pour accumuler la somme des éléments. La boucle (TANT QUE iterateur < la longueur de notes FAIRE) itère tant que iterateur est inférieur à la longueur du tableau (ici, 4). À chaque itération, l’élément `notes[iterateur]` est ajouté à moyenne, et iterateur est incrémenté de 1. Une fois la boucle terminée, la somme totale des éléments est stockée dans moyenne. Enfin, moyenne est divisée par la longueur du tableau (moyenne = moyenne / la longueur de notes) pour obtenir la moyenne arithmétique. Le résultat, un nombre rationnel, est la sortie.

Calcul de la moyenne
====================

Entrez un tableau de nombres rationnels séparés par des virgules et exécutez le pseudocode pour calculer la moyenne.

Pseudocode

Tableau de quatre nombres rationnels : notes
Variables :
  Nombre entier : iterateur = 0
  Nombre rationnel : moyenne = 0
Sorties :
  Nombre rationnel : moyenne
TANT QUE iterateur < la longueur de notes FAIRE
    moyenne = moyenne + notes\[iterateur\]
    iterateur = iterateur + 1
FIN TANT QUE
moyenne = moyenne / la longueur de notes
                

État

Tableau : \[\]

Itérateur : 0

Moyenne : 0

Prochaine étape Réinitialiser

let moyenneNotes=\[10.4,12.6,18.7,5\],moyenneIterator=0,moyenneAverage=0,moyenneStep=0,moyenneIsRunning=!1;const moyennePseudocodeLines=\["Tableau de quatre nombres rationnels : notes","Variables :"," Nombre entier : iterateur = 0"," Nombre rationnel : moyenne = 0","Sorties :"," Nombre rationnel : moyenne","TANT QUE iterateur < la longueur de notes FAIRE"," moyenne = moyenne + notes\[iterateur\]"," iterateur = iterateur + 1","FIN TANT QUE","moyenne = moyenne / la longueur de notes"\];function moyenneUpdateDisplay(){document.getElementById("moyenneArray").textContent=\`\[${moyenneNotes.join(", ")}\]\`,document.getElementById("moyenneIterator").textContent=moyenneIterator,document.getElementById("moyenneAverage").textContent=moyenneAverage.toFixed(2);const e=document.getElementById("moyennePseudocode");e.innerHTML=moyennePseudocodeLines.map((e,t)=>\`<span style="display: block; ${t===moyenneStep?"background: #e6f4ea; color: #15803d;":""}">${e}</span>\`).join(""),document.getElementById("moyenneStepButton").style.cssText=moyenneIsRunning||moyenneStep>=moyennePseudocodeLines.length?"background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: not-allowed; font-size: 16px;":"background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;"}function moyenneLog(e){const n=document.getElementById("moyenneLog"),t=document.createElement("div");t.textContent=e,t.style.cssText="opacity: 0; transition: opacity 0.5s ease;",n.appendChild(t),setTimeout(()=>{t.style.opacity="1"},10),n.scrollTop=n.scrollHeight}function moyenneValidateInput(e){const t=e.split(",").map(e=>e.trim());return t.every(e=>!isNaN(e)&&e!==""&&Number.isFinite(Number(e)))}function moyenneUpdateArray(){const e=document.getElementById("moyenneArrayInput").value;return moyenneValidateInput(e)?(moyenneNotes=e.split(",").map(e=>Number(e.trim())),moyenneReset(),!0):(alert("Veuillez entrer des nombres rationnels valides séparés par des virgules."),document.getElementById("moyenneArrayInput").value=moyenneNotes.join(", "),!1)}async function moyenneRunStep(){if(moyenneIsRunning||moyenneStep>=moyennePseudocodeLines.length)return;if(moyenneIsRunning=!0,document.getElementById("moyenneStepButton").style.cssText="background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: not-allowed; font-size: 16px;",moyenneStep===2)moyenneIterator=0,moyenneLog("Initialisation : itérateur = 0");else if(moyenneStep===3)moyenneAverage=0,moyenneLog("Initialisation : moyenne = 0");else if(moyenneStep===6)moyenneIterator<moyenneNotes.length?moyenneLog(\`Vérification : itérateur (${moyenneIterator}) < longueur de notes (${moyenneNotes.length})\`):(moyenneLog(\`Vérification : itérateur (${moyenneIterator}) >= longueur de notes (${moyenneNotes.length}), sortie de la boucle\`),moyenneStep=9);else if(moyenneStep===7){const e=moyenneAverage;moyenneAverage+=moyenneNotes\[moyenneIterator\],moyenneLog(\`Moyenne = ${e.toFixed(2)} + notes\[${moyenneIterator}\] = ${moyenneAverage.toFixed(2)}\`)}else if(moyenneStep===8)moyenneIterator++,moyenneLog(\`Itérateur = ${moyenneIterator-1} + 1 = ${moyenneIterator}\`),moyenneStep=5;else if(moyenneStep===10){const e=moyenneAverage;moyenneAverage/=moyenneNotes.length,moyenneLog(\`Moyenne = ${e.toFixed(2)} / ${moyenneNotes.length} = ${moyenneAverage.toFixed(2)}\`)}moyenneStep++,moyenneUpdateDisplay(),await new Promise(e=>setTimeout(e,500)),moyenneIsRunning=!1,moyenneUpdateDisplay()}function moyenneReset(){moyenneIterator=0,moyenneAverage=0,moyenneStep=0,document.getElementById("moyenneLog").innerHTML="",moyenneUpdateDisplay()}document.getElementById("moyenneArrayInput").addEventListener("change",moyenneUpdateArray),document.getElementById("moyenneStepButton").addEventListener("click",moyenneRunStep),document.getElementById("moyenneResetButton").addEventListener("click",()=>{moyenneUpdateArray()&&moyenneReset()}),moyenneUpdateDisplay()

Observez comment on termine la boucle “TANT QUE” avec une ligne “FIN TANT QUE”. Ce n’est pas nécessaire, mais vous devez être clair et précis quant au début et à la fin de vos opérations. On peut aussi indiquer le début et la fin d’une boucle avec l’indentation, ou tout autre moyen compris par les êtres humains. L’expression “TANT QUE” est associée à une condition qui peut être vraie ou fausse. L’exécution se poursuit tant que l’expression est vraie, et elle se termine lorsque l’expression est fausse.

Pour montrer comment ce pseudo-code se traduit dans des langages réels, considérons un tableau contenant les notes {10.4, 12.6, 18.7, 5.0} et calculons sa moyenne en utilisant une boucle qui parcourt les indices.

En Java, on utilise un tableau ou un ArrayList, mais ici avec un tableau fixe :

    double[] notes = {10.4, 12.6, 18.7, 5.0};
    double somme = 0;
    for (int i = 0; i < notes.length; i++) {
        somme += notes[i];
    }
    double moyenne = somme / notes.length;
    System.out.println(moyenne);
    

En JavaScript, les tableaux sont dynamiques et la propriété length donne directement la taille :

    let notes = [10.4, 12.6, 18.7, 5.0];
    let somme = 0;
    for (let i = 0; i < notes.length; i++) {
        somme += notes[i];
    }
    let moyenne = somme / notes.length;
    console.log(moyenne);
    

En Go, on utilise un slice et la fonction len pour obtenir la longueur :

    notes := []float64{10.4, 12.6, 18.7, 5.0}
    somme := 0.0
    for i := 0; i < len(notes); i++ {
        somme += notes[i]
    }
    moyenne := somme / float64(len(notes))
    fmt.Println(moyenne)
    

En C++, on peut utiliser un std::vector ou un tableau classique ; ici avec un initializer list et un vector :

    #include <iostream>
    #include <vector>
    
    std::vector<double> notes = {10.4, 12.6, 18.7, 5.0};
    double somme = 0;
    for (size_t i = 0; i < notes.size(); i++) {
        somme += notes[i];
    }
    double moyenne = somme / notes.size();
    std::cout << moyenne << std::endl;
    

Dans chaque cas, la structure reste fidèle au pseudo-code : initialisation d’une somme à zéro, parcours des indices de 0 à longueur-1 avec incrémentation, accumulation des valeurs, puis division finale par le nombre d’éléments. Cette approche rend l’algorithme indépendant de la taille exacte du tableau, exactement comme souhaité dans la version générale en pseudo-code.

 [![Previous](/inf1220-hugo/svg/backward.svg "Les ordinateurs et leurs langages") Les ordinateurs et leurs langages](/inf1220-hugo/docs/modules/module1/ordinateurs/) [Les algorithmes : conception et syntaxe ![Next](/inf1220-hugo/svg/forward.svg "Les algorithmes : conception et syntaxe")](/inf1220-hugo/docs/modules/module1/algorithmes2/) 

(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()

*   [Préalables](#préalables)
*   [Introduction](#introduction)
    *   [Qu’est-ce qu’un algorithme ?](#quest-ce-quun-algorithme-)
    *   [Qu’est-ce que le pseudo-code ?](#quest-ce-que-le-pseudo-code-)
    *   [Variables et valeurs](#variables-et-valeurs)
    *   [Logique booléenne](#logique-booléenne)
    *   [Notation des programmeurs](#notation-des-programmeurs)
*   [La boucle](#la-boucle)
*   [Tableau](#tableau)
*   [Exemple : Calcul de la moyenne](#exemple--calcul-de-la-moyenne)