Les problèmes difficiles | INF 1220 - Introduction à la programmation 

[![Logo](/inf1220-hugo/livre.jpg)INF 1220 - Introduction à la programmation](/inf1220-hugo/)
--------------------------------------------------------------------------------------------

document.querySelector(".book-search").classList.remove("hidden")

*   [Programmation Java en ligne](/inf1220-hugo/docs/environnement/)
*   [Formattage du code Java](/inf1220-hugo/docs/format/)
*   [Vous avez trouvé une erreur?](/inf1220-hugo/docs/erreurs/)
*   [Modules](/inf1220-hugo/docs/modules/)
    *    [Module 1: Algorithme et pseudocode](/inf1220-hugo/docs/modules/module1/)
        *   [Modèle du cours](/inf1220-hugo/docs/modules/module1/teluq/)
        *   [Robot conversationnel et intelligence artificielle](/inf1220-hugo/docs/modules/module1/robot/)
        *   [Autoévaluation](/inf1220-hugo/docs/modules/module1/autoevaluation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module1/pasapas/)
        *   [Les ordinateurs et leurs langages](/inf1220-hugo/docs/modules/module1/ordinateurs/)
        *   [Les algorithmes](/inf1220-hugo/docs/modules/module1/algorithmes/)
        *   [Les algorithmes : conception et syntaxe](/inf1220-hugo/docs/modules/module1/algorithmes2/)
        *   [Les algorithmes: les structures de contrôle](/inf1220-hugo/docs/modules/module1/algorithmes3/)
        *   [Les problèmes difficiles](/inf1220-hugo/docs/modules/module1/difficile/)
        *   [Complexité algorithmique](/inf1220-hugo/docs/modules/module1/complex/)
        *   [Les erreurs communes](/inf1220-hugo/docs/modules/module1/erreurs/)
        *   [Présentation du pseudocode](/inf1220-hugo/docs/modules/module1/syntaxe/)
        *   [Exercices sur les algorithmes](/inf1220-hugo/docs/modules/module1/exercices/)
        *   [Travail noté 1](/inf1220-hugo/docs/modules/module1/travail-note-1/)
    *    [Module 2: Introduction au langage Java](/inf1220-hugo/docs/modules/module2/)
        *   [Préparation de l’espace de travail](/inf1220-hugo/docs/modules/module2/preparation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module2/pasapas/)
        *   [Création d'une classe en Java](/inf1220-hugo/docs/modules/module2/oriente/)
        *   [Introduction aux types de base et à leurs opérateurs](/inf1220-hugo/docs/modules/module2/typeoperateur/)
        *   [Exercices sur les classes, les variables, les types et les opérateurs](/inf1220-hugo/docs/modules/module2/exercices-2-1/)
        *   [Méthodes et constructeurs](/inf1220-hugo/docs/modules/module2/methodes/)
        *   [Exercices sur les classes et méthodes](/inf1220-hugo/docs/modules/module2/exercices-2-2/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module2/conseils/)
        *   [MarkDown](/inf1220-hugo/docs/modules/module2/markdown/)
        *   [Gabarit pour les travaux notés 2, 3, 4 et 5](/inf1220-hugo/docs/modules/module2/gabarit/)
        *   [Travail noté 2](/inf1220-hugo/docs/modules/module2/travail-note-2/)
    *    [Module 3: Les structures de données, de contrôle et d'itération en Java](/inf1220-hugo/docs/modules/module3/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module3/pasapas/)
        *   [GitHub](/inf1220-hugo/docs/modules/module3/github/)
        *   [Les structures de contrôle](/inf1220-hugo/docs/modules/module3/activite-3-1/)
        *   [Les structures itératives](/inf1220-hugo/docs/modules/module3/activite-3-2/)
        *   [Les chaînes de caractères (String)](/inf1220-hugo/docs/modules/module3/activite-3-3-string/)
        *   [Les structures de données de base](/inf1220-hugo/docs/modules/module3/activite-3-3/)
        *   [Les valeurs aléatoires](/inf1220-hugo/docs/modules/module3/activite-3-3-random/)
        *   [La programmation fonctionnelle en Java](/inf1220-hugo/docs/modules/module3/fonctionnel/)
        *   [Exercices sur les structures de contrôle, les structures de données, les structures itératives](/inf1220-hugo/docs/modules/module3/exercices-3-1/)
        *   [Les exceptions](/inf1220-hugo/docs/modules/module3/activite-3-4/)
        *   [La récursivité](/inf1220-hugo/docs/modules/module3/activite-3-5/)
        *   [Exercices sur les exceptions et la récursivité](/inf1220-hugo/docs/modules/module3/exercices-3-2/)
        *   [Exemple : modèle de langue](/inf1220-hugo/docs/modules/module3/activite-3-3-modele/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module3/conseils/)
        *   [Travail noté 3](/inf1220-hugo/docs/modules/module3/travail-note-3/)
    *    [Module 4: Les entrées et sorties](/inf1220-hugo/docs/modules/module4/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module4/pasapas/)
        *   [Les flux de console](/inf1220-hugo/docs/modules/module4/activite-4-1/)
        *   [Les flux de données: lecture dans des fichiers et autres](/inf1220-hugo/docs/modules/module4/activite-4-2/)
        *   [Exercices sur les flux](/inf1220-hugo/docs/modules/module4/exercices-4-1/)
        *   [Développement web](/inf1220-hugo/docs/modules/module4/web/)
        *   [Travail noté 4](/inf1220-hugo/docs/modules/module4/travail-note-4/)
    *    [Module 5. La programmation orientée objet: héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module5/pasapas/)
        *   [L'héritage, les classes abstraites et les interfaces](/inf1220-hugo/docs/modules/module5/activite-5-1/)
        *   [Le polymorphisme](/inf1220-hugo/docs/modules/module5/activite-5-2/)
        *   [Exercices sur l’héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/exercices-5-1/)
        *   [Travail noté 5](/inf1220-hugo/docs/modules/module5/travail-note-5/)
    *   [Examen](/inf1220-hugo/docs/modules/examen/)
*   [Évaluation](/inf1220-hugo/docs/evaluation/)
*   [Pense-bête java](/inf1220-hugo/docs/pensebete/)
*    Autres ressources
    *   [Le professeur](/inf1220-hugo/docs/extra/credits/)
    *   [Feuille de route](/inf1220-hugo/docs/extra/feuille-de-route/)
    *   [Ressources](/inf1220-hugo/docs/extra/ressources/)
    *   [FAQ](/inf1220-hugo/docs/extra/faq/)
    *   [Manuel](/inf1220-hugo/docs/extra/manuel/)
    *   [Rappel mathématique](/inf1220-hugo/docs/extra/math/)
    *   [Intelligence artificielle](/inf1220-hugo/docs/extra/ia/)
    *   [Petit guide d’usage du courriel efficace](/inf1220-hugo/docs/extra/courriel/)

(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()

![Menu](/inf1220-hugo/svg/menu.svg)

### Les problèmes difficiles

![Table of Contents](/inf1220-hugo/svg/toc.svg)

Les problèmes difficiles [#](#les-probl%c3%a8mes-difficiles)
============================================================

> Dans ce cours, vous n’avez pas à maîtriser la notion de problème difficile, mais vous devriez être familier avec le concept.

Dans un cours d’introduction à la programmation, la plupart des exercices se concentrent sur des problèmes dont les algorithmes sont relativement simples à concevoir, surtout si vous maîtrisez les bases de la programmation et des mathématiques. Ces problèmes, comme calculer une moyenne ou trier une liste, demandent souvent une compréhension des structures de contrôle (conditions et boucles) et une application directe de concepts logiques. Cependant, dans des contextes plus avancés, certains problèmes se révèlent bien plus complexes, non pas à cause de la programmation elle-même, mais en raison de la difficulté à trouver un algorithme efficace. Ces défis, qualifiés de « problèmes difficiles », nécessitent des approches créatives et parfois des compromis, car leurs solutions idéales peuvent être hors de portée avec les ressources informatiques actuelles.

Les problèmes difficiles se rencontrent fréquemment dans des domaines comme l’intelligence artificielle, l’optimisation ou la cryptographie. Par exemple, développer une intelligence artificielle capable de rivaliser avec un grand maître aux échecs exige non seulement de programmer des règles du jeu, mais aussi de concevoir un algorithme capable d’évaluer des millions de positions possibles en un temps raisonnable. Ce type de problème est complexe, car il combine une exploration stratégique (choisir les meilleurs coups) avec des contraintes de performance (limiter le temps de calcul). De même, des problèmes d’optimisation, comme déterminer le chemin le plus court pour un livreur effectuant plusieurs arrêts, peuvent sembler simples en théorie, mais deviennent rapidement ingérables à mesure que le nombre de destinations augmente, en raison du nombre exponentiel de combinaisons possibles.

Un exemple classique de problème difficile est le problème du voyageur de commerce (TSP, pour Traveling Salesman Problem). Ce problème consiste à trouver le chemin le plus court permettant à un voyageur de visiter une liste de villes exactement une fois avant de revenir à son point de départ. Pour un petit nombre de villes, il est possible d’énumérer toutes les permutations et de calculer la distance totale de chaque trajet. Cependant, avec seulement 20 villes, le nombre de trajets possibles dépasse les milliards, rendant une approche par force brute (tester toutes les combinaisons) impraticable, même sur des ordinateurs puissants. Ce problème est dit « NP-difficile », un terme technique que les informaticiens utilisent pour désigner un problème qu’il est difficile de résoudre rapidement en général.

Pour aborder le problème du voyageur de commerce, des algorithmes approchés, comme l’algorithme du plus proche voisin, sont souvent utilisés. Cet algorithme commence par une ville arbitraire, puis choisit à chaque étape la ville la plus proche non visitée, jusqu’à ce que toutes les villes soient incluses, avant de revenir à la ville de départ. Bien que cette méthode ne garantisse pas toujours le chemin le plus court, elle produit une solution acceptable dans un temps de calcul bien plus court que l’énumération complète. Voici un pseudocode pour cet algorithme :

    Entrées :
      Liste de villes : villes[n]
      Matrice des distances : distances[n][n]
    
    Sorties :
      Liste ordonnée des villes : trajet
    
    Initialiser trajet comme une liste vide
    Choisir une ville de départ (par exemple, villes[0]) et l’ajouter à trajet
    Marquer la ville de départ comme visitée
    TANT QUE toutes les villes ne sont pas visitées FAIRE
        Trouver la ville non visitée la plus proche de la dernière ville dans trajet
        Ajouter cette ville à trajet
        Marquer cette ville comme visitée
    FIN TANT QUE
    Ajouter la ville de départ à la fin de trajet pour boucler
    RETOURNER trajet
    

Ce pseudocode décrit une solution gloutonne au problème du voyageur de commerce (TSP), qui cherche un circuit visitant chaque ville d’une liste exactement une fois et revenant à la ville de départ, en minimisant la distance totale. Les entrées sont une liste de n villes (`villes[n]`) et une matrice `distances[n][n]` indiquant les distances entre chaque paire de villes. Une liste trajet est initialisée vide pour stocker l’ordre des villes. L’algorithme commence par choisir une ville de départ (par exemple, `villes[0]`), l’ajoute à trajet, et la marque comme visitée. Une boucle (TANT QUE toutes les villes ne sont pas visitées FAIRE) sélectionne à chaque étape la ville non visitée la plus proche de la dernière ville ajoutée à trajet, en consultant la matrice distances. Cette ville est ajoutée à trajet et marquée comme visitée. Une fois toutes les villes visitées, la ville de départ est ajoutée à la fin de trajet pour former un circuit fermé. La liste trajet est retournée comme résultat.

Considérons une table (fictive) des distances entre certains villes du Québec.

Ville

Montréal

Québec

Laval

Gatineau

Longueuil

Montréal

\-

250

20

200

15

Québec

250

\-

240

450

245

Laval

20

240

\-

210

30

Gatineau

200

450

210

\-

210

Longueuil

15

245

30

210

\-

Vous pouvez vérifier que le trajet suivant représente 910 km.

Montréal -> Gatineau -> Laval -> Québec -> Longueuil -> Montréal

Maintenant, exécutez l’algorithme du plus proche voisin avec l’application suivante :

Problème du voyageur de commerce (TSP)
--------------------------------------

### Pseudocode (Approche du plus proche voisin)

Entrées :
  Liste de villes : villes\[n\]
  Matrice des distances : distances\[n\]\[n\]

Sorties :
  Liste ordonnée des villes : trajet

Initialiser trajet comme une liste vide
Choisir une ville de départ aléatoire et l’ajouter à trajet
Marquer la ville de départ comme visitée
TANT QUE toutes les villes ne sont pas visitées FAIRE
    Trouver la ville non visitée la plus proche de la dernière ville dans trajet
    Ajouter cette ville à trajet
    Marquer cette ville comme visitée
FIN TANT QUE
Ajouter la ville de départ à la fin de trajet pour boucler
RETOURNER trajet, Distance totale
            

### Tableau des distances (km)

Ville

Montréal

Québec

Laval

Gatineau

Longueuil

Montréal

\-

250

20

200

15

Québec

250

\-

240

450

245

Laval

20

240

\-

210

30

Gatineau

200

450

210

\-

210

Longueuil

15

245

30

210

\-

Commencer Réinitialiser

### État actuel

Cliquez sur 'Commencer' pour commencer l'initialisation.

Étape : 0

Trajet actuel :

Distance totale parcourue : 0 km

const TSPApp=function(){const t=\["Montréal","Québec","Laval","Gatineau","Longueuil"\],h=\[\[0,250,20,200,15\],\[250,0,240,450,245\],\[20,240,0,210,30\],\[200,450,210,0,210\],\[15,245,30,210,0\]\];let i=\[\],l=new Array(t.length).fill(!1),e=-1,a=-1,r=0,s=0,c=!1;const \_=\["Entrées :"," Liste de villes : villes\[n\]"," Matrice des distances : distances\[n\]\[n\]","","Sorties :"," Liste ordonnée des villes : trajet","","Initialiser trajet comme une liste vide","Choisir une ville de départ aléatoire et l’ajouter à trajet","Marquer la ville de départ comme visitée","TANT QUE toutes les villes ne sont pas visitées FAIRE"," Trouver la ville non visitée la plus proche de la dernière ville dans trajet"," Ajouter cette ville à trajet"," Marquer cette ville comme visitée","FIN TANT QUE","Ajouter la ville de départ à la fin de trajet pour boucler","RETOURNER trajet, Distance totale"\],o=document.getElementById("tsp-next-btn"),j=document.getElementById("tsp-reset-btn"),n=document.getElementById("tsp-message"),u=document.getElementById("tsp-step"),m=document.getElementById("tsp-trajet"),f=document.getElementById("tsp-distance"),y=document.getElementById("tsp-pseudocode"),p=document.getElementById("tsp-distance-table");function g(){const e={0:7,1:8,2:9,3:10,4:11,5:12,6:13,7:15,8:16},t=e\[s\]||-1;y.innerHTML=\_.map((e,n)=>n+1===t?\`<span style="background-color: #fefcbf; padding: 2px 4px; border-radius: 4px;">${e}</span>\`:e).join(\` \`)}function v(){const t=p.querySelectorAll("tbody tr"),n=p.querySelectorAll("thead th");if(e===-1){t.forEach(e=>{e.querySelectorAll("td").forEach(e=>{e.style.backgroundColor=""})}),n.forEach(e=>{e.style.backgroundColor="#2b6cb0"});return}e!==-1&&!c&&(n\[e+1\]&&(n\[e+1\].style.backgroundColor="#9ae6b4"),t\[e\]&&t\[e\].querySelectorAll("td").forEach((e)=>{e.style.backgroundColor="#fefcbf"}),t.forEach((t)=>{const s=t.querySelectorAll("td")\[e+1\];s&&(s.style.backgroundColor="#fefcbf")}))}function d(){i=\[\],l=new Array(t.length).fill(!1),e=-1,a=-1,r=0,s=0,c=!1,n.textContent="Cliquez sur 'Commencer' pour commencer l'initialisation.",u.textContent=\`Étape : 0\`,m.textContent=\`Trajet actuel : \`,f.textContent=\`Distance totale parcourue : 0 km\`,o.textContent="Commencer",o.disabled=!1,v(),g()}function b(){if(c){n.textContent=\`Algorithme terminé. Trajet final : ${i.join(" → ")}. Distance totale : ${r} km. Cliquez sur 'Réinitialiser' pour recommencer.\`,o.disabled=!0;return}switch(s){case 0:i=\[\],l=new Array(t.length).fill(!1),n.textContent="Le trajet est initialisé. Prêt à choisir une ville de départ.",s=1,o.textContent="Suivant";break;case 1:a=Math.floor(Math.random()\*t.length),i.push(t\[a\]),e=a,n.textContent=\`Ville de départ choisie aléatoirement : ${t\[a\]}.\`,s=2;break;case 2:l\[e\]=!0,n.textContent=\`Ville de départ (${t\[e\]}) marquée comme visitée.\`,s=3;break;case 3:i.length===t.length?(n.textContent="Toutes les villes ont été visitées. Ajout de la ville de départ pour boucler le trajet.",s=7):(n.textContent="Toutes les villes ne sont pas encore visitées. Recherche de la ville la plus proche.",s=4);break;case 4:let u=1/0,m=-1;for(let n=0;n<t.length;n++)if(!l\[n\]){const t=h\[e\]\[n\];t<u&&(u=t,m=n)}if(m===-1){n.textContent="Erreur: Aucune ville non visitée trouvée. L'algorithme est bloqué. Réinitialisez.",c=!0,o.textContent="Terminé",o.disabled=!0;break}o.dataset.nextCityIdx=m,o.dataset.minD=u,n.textContent=\`La ville la plus proche de ${t\[e\]} est ${t\[m\]} (distance ${u} km).\`,s=5;break;case 5:const f=parseInt(o.dataset.nextCityIdx),g=parseInt(o.dataset.minD);i.push(t\[f\]),r+=g,e=f,n.textContent=\`Ajout de ${t\[f\]} au trajet. Distance cumulée : ${r} km.\`,s=6;break;case 6:l\[e\]=!0,n.textContent=\`Ville ${t\[e\]} marquée comme visitée.\`,s=3;break;case 7:const p=h\[e\]\[a\];i.push(t\[a\]),r+=p,n.textContent=\`Retour à la ville de départ (${t\[a\]}) pour boucler (distance ${p} km).\`,s=8;break;case 8:c=!0,n.textContent=\`Algorithme terminé. Trajet final : ${i.join(" → ")}. Distance totale : ${r} km.\`,o.textContent="Terminé",o.disabled=!0;break;default:n.textContent="État inconnu. Réinitialisation.",d();break}u.textContent=\`Étape : ${s}\`,m.textContent=\`Trajet actuel : ${i.join(" → ")}\`,f.textContent=\`Distance totale parcourue : ${r} km\`,v(),g()}return o.addEventListener("click",b),j.addEventListener("click",d),d(),{initialize:d,nextStep:b}}()

Pouvez-vous obtenir une distance aussi courte que 910 km ;? Comment pourriez-vous modifier le pseudocode pour obtenir toujours la distance la plus courte ? C’est une question difficile.

Cet exemple d’algorithme est un algorithme glouton. Un algorithme glouton est une méthode algorithmique qui résout un problème en faisant à chaque étape le choix localement optimal, dans l’espoir que ces choix mènent à une solution globale optimale. Il privilégie la simplicité et la rapidité, mais ne garantit pas toujours la meilleure solution pour tous les problèmes, car il ne revient jamais en arrière pour réévaluer les décisions prises. Ce type d’algorithme est souvent utilisé pour des problèmes d’optimisation où une solution approximative est acceptable ou lorsque le problème possède une structure particulière, comme la propriété de sous-structure optimale ou la propriété gloutonne.

Considérons d’autres exemples de l’approche gloutonne.

*   Suppose que nous disposions d’un sac à dos de capacité limitée et d’objets ayant chacun un poids et une valeur. L’objectif est de maximiser la valeur totale des objets dans le sac, en autorisant des fractions d’objets. L’approche gloutonne dans ce cas consiste à d’abord trier les objets par rapport décroissant de leur rapport valeur/poids. Ensuite, il faut remplir le sac en prenant autant que possible de chaque objet dans cet ordre jusqu’à atteindre la capacité.
*   Suppose que nous disposions d’un ensemble d’activités avec des heures de début et de fin, et l’objectif est de sélectionner le plus grand nombre d’activités compatibles (qui ne se chevauchent pas). Une approche gloutonne consiste à trier les activités par heure de fin croissante. Sélectionner la première activité, puis la prochaine activité compatible, et ainsi de suite.

Les approches gloutonnes donnent généralement une solution qui n’est pas optimale.

Dans le cadre de ce cours, vous ne serez pas confronté à des problèmes aussi complexes que le voyageur de commerce. Les exercices proposés viseront à renforcer votre compréhension des bases algorithmiques, comme les boucles, les conditions et la manipulation de données simples. Cependant, il est utile de connaître l’existence de ces problèmes difficiles pour apprécier la profondeur de l’informatique. Ils illustrent l’importance de l’efficacité algorithmique et des compromis dans la conception de solutions. En explorant des cas plus simples, vous poserez les fondations nécessaires pour, un jour, peut-être, relever ces défis plus ardus.

 [![Previous](/inf1220-hugo/svg/backward.svg "Les algorithmes: les structures de contrôle") Les algorithmes: les structures de contrôle](/inf1220-hugo/docs/modules/module1/algorithmes3/) [Complexité algorithmique ![Next](/inf1220-hugo/svg/forward.svg "Complexité algorithmique")](/inf1220-hugo/docs/modules/module1/complex/) 

(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()