Complexité algorithmique | INF 1220 - Introduction à la programmation 

[![Logo](/inf1220-hugo/livre.jpg)INF 1220 - Introduction à la programmation](/inf1220-hugo/)
--------------------------------------------------------------------------------------------

document.querySelector(".book-search").classList.remove("hidden")

*   [Programmation Java en ligne](/inf1220-hugo/docs/environnement/)
*   [Formattage du code Java](/inf1220-hugo/docs/format/)
*   [Vous avez trouvé une erreur?](/inf1220-hugo/docs/erreurs/)
*   [Modules](/inf1220-hugo/docs/modules/)
    *    [Module 1: Algorithme et pseudocode](/inf1220-hugo/docs/modules/module1/)
        *   [Modèle du cours](/inf1220-hugo/docs/modules/module1/teluq/)
        *   [Robot conversationnel et intelligence artificielle](/inf1220-hugo/docs/modules/module1/robot/)
        *   [Autoévaluation](/inf1220-hugo/docs/modules/module1/autoevaluation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module1/pasapas/)
        *   [Les ordinateurs et leurs langages](/inf1220-hugo/docs/modules/module1/ordinateurs/)
        *   [Les algorithmes](/inf1220-hugo/docs/modules/module1/algorithmes/)
        *   [Les algorithmes : conception et syntaxe](/inf1220-hugo/docs/modules/module1/algorithmes2/)
        *   [Les algorithmes: les structures de contrôle](/inf1220-hugo/docs/modules/module1/algorithmes3/)
        *   [Les problèmes difficiles](/inf1220-hugo/docs/modules/module1/difficile/)
        *   [Complexité algorithmique](/inf1220-hugo/docs/modules/module1/complex/)
        *   [Les erreurs communes](/inf1220-hugo/docs/modules/module1/erreurs/)
        *   [Présentation du pseudocode](/inf1220-hugo/docs/modules/module1/syntaxe/)
        *   [Exercices sur les algorithmes](/inf1220-hugo/docs/modules/module1/exercices/)
        *   [Travail noté 1](/inf1220-hugo/docs/modules/module1/travail-note-1/)
    *    [Module 2: Introduction au langage Java](/inf1220-hugo/docs/modules/module2/)
        *   [Préparation de l’espace de travail](/inf1220-hugo/docs/modules/module2/preparation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module2/pasapas/)
        *   [Création d'une classe en Java](/inf1220-hugo/docs/modules/module2/oriente/)
        *   [Introduction aux types de base et à leurs opérateurs](/inf1220-hugo/docs/modules/module2/typeoperateur/)
        *   [Exercices sur les classes, les variables, les types et les opérateurs](/inf1220-hugo/docs/modules/module2/exercices-2-1/)
        *   [Méthodes et constructeurs](/inf1220-hugo/docs/modules/module2/methodes/)
        *   [Exercices sur les classes et méthodes](/inf1220-hugo/docs/modules/module2/exercices-2-2/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module2/conseils/)
        *   [MarkDown](/inf1220-hugo/docs/modules/module2/markdown/)
        *   [Gabarit pour les travaux notés 2, 3, 4 et 5](/inf1220-hugo/docs/modules/module2/gabarit/)
        *   [Travail noté 2](/inf1220-hugo/docs/modules/module2/travail-note-2/)
    *    [Module 3: Les structures de données, de contrôle et d'itération en Java](/inf1220-hugo/docs/modules/module3/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module3/pasapas/)
        *   [GitHub](/inf1220-hugo/docs/modules/module3/github/)
        *   [Les structures de contrôle](/inf1220-hugo/docs/modules/module3/activite-3-1/)
        *   [Les structures itératives](/inf1220-hugo/docs/modules/module3/activite-3-2/)
        *   [Les chaînes de caractères (String)](/inf1220-hugo/docs/modules/module3/activite-3-3-string/)
        *   [Les structures de données de base](/inf1220-hugo/docs/modules/module3/activite-3-3/)
        *   [Les valeurs aléatoires](/inf1220-hugo/docs/modules/module3/activite-3-3-random/)
        *   [La programmation fonctionnelle en Java](/inf1220-hugo/docs/modules/module3/fonctionnel/)
        *   [Exercices sur les structures de contrôle, les structures de données, les structures itératives](/inf1220-hugo/docs/modules/module3/exercices-3-1/)
        *   [Les exceptions](/inf1220-hugo/docs/modules/module3/activite-3-4/)
        *   [La récursivité](/inf1220-hugo/docs/modules/module3/activite-3-5/)
        *   [Exercices sur les exceptions et la récursivité](/inf1220-hugo/docs/modules/module3/exercices-3-2/)
        *   [Exemple : modèle de langue](/inf1220-hugo/docs/modules/module3/activite-3-3-modele/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module3/conseils/)
        *   [Travail noté 3](/inf1220-hugo/docs/modules/module3/travail-note-3/)
    *    [Module 4: Les entrées et sorties](/inf1220-hugo/docs/modules/module4/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module4/pasapas/)
        *   [Les flux de console](/inf1220-hugo/docs/modules/module4/activite-4-1/)
        *   [Les flux de données: lecture dans des fichiers et autres](/inf1220-hugo/docs/modules/module4/activite-4-2/)
        *   [Exercices sur les flux](/inf1220-hugo/docs/modules/module4/exercices-4-1/)
        *   [Développement web](/inf1220-hugo/docs/modules/module4/web/)
        *   [Travail noté 4](/inf1220-hugo/docs/modules/module4/travail-note-4/)
    *    [Module 5. La programmation orientée objet: héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module5/pasapas/)
        *   [L'héritage, les classes abstraites et les interfaces](/inf1220-hugo/docs/modules/module5/activite-5-1/)
        *   [Le polymorphisme](/inf1220-hugo/docs/modules/module5/activite-5-2/)
        *   [Exercices sur l’héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/exercices-5-1/)
        *   [Travail noté 5](/inf1220-hugo/docs/modules/module5/travail-note-5/)
    *   [Examen](/inf1220-hugo/docs/modules/examen/)
*   [Évaluation](/inf1220-hugo/docs/evaluation/)
*   [Pense-bête java](/inf1220-hugo/docs/pensebete/)
*    Autres ressources
    *   [Le professeur](/inf1220-hugo/docs/extra/credits/)
    *   [Feuille de route](/inf1220-hugo/docs/extra/feuille-de-route/)
    *   [Ressources](/inf1220-hugo/docs/extra/ressources/)
    *   [FAQ](/inf1220-hugo/docs/extra/faq/)
    *   [Manuel](/inf1220-hugo/docs/extra/manuel/)
    *   [Rappel mathématique](/inf1220-hugo/docs/extra/math/)
    *   [Intelligence artificielle](/inf1220-hugo/docs/extra/ia/)
    *   [Petit guide d’usage du courriel efficace](/inf1220-hugo/docs/extra/courriel/)

(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()

![Menu](/inf1220-hugo/svg/menu.svg)

### Complexité algorithmique

![Table of Contents](/inf1220-hugo/svg/toc.svg)

*   *   [Notation grand-O](#notation-grand-o)
    *   [Notation grand-O](#notation-grand-o-1)
    *   [Exemples d’algorithmes en](#exemples-dalgorithmes-en)
    *   [Exemples d’algorithmes en](#exemples-dalgorithmes-en-1)
    *   [Recherche dans un tableau trié](#recherche-dans-un-tableau-trié)
    *   [Tri](#tri)
    *   [Table de hachage](#table-de-hachage)
    *   [Un problème résoluble en ou en](#un-problème-résoluble-en--ou-en)
    *   [Les arbres en informatique](#les-arbres-en-informatique)
*   [Analyse amortie](#analyse-amortie)
*   [Vidéo optionnelle](#vidéo-optionnelle)

Complexité algorithmique [#](#complexit%c3%a9-algorithmique)
============================================================

La plupart des problèmes ne sont pas fondamentalement difficiles, mais toutes les solutions ne sont pas également efficaces. La complexité algorithmique fournit une mesure de cette efficacité.

La complexité algorithmique mesure le temps ou la mémoire qu’un algorithme nécessite en fonction de la taille de l’entrée (souvent notée \\( n \\)). Pour comparer les algorithmes, on utilise la notation grand-O (ou O-grande), qui donne un ordre de grandeur du nombre d’opérations à effectuer lorsque la taille des données augmente.

Comprendre la complexité algorithmique permet de choisir ou d’inventer des solutions efficaces, surtout pour de grandes quantités de données. Il est souvent utile de commencer par une solution simple (même lente), puis de chercher à l’optimiser en utilisant des structures de données ou des propriétés mathématiques adaptées.

> Dans ce cours, vous n’avez pas à maîtriser la notation grand-O et la complexité algorithmique. Néanmoins, il est utile d’être familier avec les principales notions.

### Notation grand-O [#](#notation-grand-o)

La notation \\( O(f(n)) \\) signifie que, pour des entrées de taille \\( n \\), l’algorithme effectue au plus un nombre d’opérations proportionnel à \\( f(n) \\) (à une constante près). On ne s’intéresse qu’au comportement pour de grandes valeurs de \\( n \\), et on ignore les détails d’implémentation ou les constantes cachées.

On considère souvent que l’accès à un élément d’un tableau par son index a une complexité \\( O(1) \\) puisqu’il s’agit d’une seule opération. Les operations arithmétique (+, -, etc.) ont aussi une complexité \\( O(1) \\).

### Notation grand-O [#](#notation-grand-o-1)

La notation \\( O(f(n)) \\) signifie que, pour des entrées de taille \\( n \\), l’algorithme effectue au plus un nombre d’opérations proportionnel à \\( f(n) \\) (à une constante près). On ne s’intéresse qu’au comportement pour de grandes valeurs de \\( n \\), et on ignore les détails d’implémentation ou les constantes cachées.

On considère souvent que l’accès à un élément d’un tableau par son index a une complexité \\( O(1) \\) puisqu’il s’agit d’une seule opération. Les opérations arithmétiques (+, -, etc.) ont aussi une complexité \\( O(1) \\).

Cette notation permet également de comparer différentes classes de complexité. Une hiérarchie courante observe que les algorithmes en complexité constante sont les plus efficaces pour de grandes entrées, suivis de ceux en complexité logarithmique (\\(O(\\log n)\\)), puis linéaire (\\(O(n)\\)), linéarithmique (\\(O(n\\log n)\\)), et enfin quadratique (\\(O(n^2\\)). Formellement, cela se traduit par des inclusions entre les classes : \\( O(1) \\subseteq O(\\log n) \\subseteq O(n) \\subseteq O(n \\log n) \\subseteq O(n^2) \\), où le logarithme est pris en base quelconque supérieure à 1 (la base n’affecte la définition qu’à une constante multiplicative près).

Pour établir ces inclusions, rappelons la définition : une fonction \\( g(n) \\) appartient à \\( O(f(n)) \\) s’il existe une constante positive \\( c \\) et un entier \\( n\_0 \\) tels que, pour tout \\( n \\geq n\_0 \\), \\( g(n) \\leq c \\cdot f(n) \\) (en considérant des fonctions positives pour \\( n \\) grand).

Considérons le logarithme en base 2 pour les preuves explicites, sans perte de généralité.

Pour \\( O(1) \\subseteq O(\\log n) \\) : toute fonction constante, disons \\( g(n) = k \\), satisfait l’inclusion. Comme \\( \\log\_2 n \\to \\infty \\) lorsque \\( n \\to \\infty \\), il existe \\( n\_0 \\) tel que \\( \\log\_2 n \\geq k \\) pour \\( n \\geq n\_0 \\). Ainsi, avec \\( c = 1 \\), \\( k \\leq \\log\_2 n \\) pour \\( n \\geq n\_0 \\).

Pour \\( O(\\log n) \\subseteq O(n) \\) : prenons \\( g(n) = \\log\_2 n \\). Il est clair que \\( \\log\_2 n \\leq n \\) pour tout \\( n \\geq 1 \\) (vérifiable pour petits \\( n \\), et évident asymptotiquement puisque la fonction exponentielle croît plus vite). Plus précisément, le limite \\( \\frac{\\log\_2 n}{n} \\to 0 \\) quand \\( n \\to \\infty \\) implique l’existence de \\( c = 1 \\) et \\( n\_0 = 1 \\) tels que \\( \\log\_2 n \\leq n \\).

Pour \\( O(n) \\subseteq O(n \\log n) \\) : pour \\( g(n) = n \\), observons que \\( \\log\_2 n \\geq 1 \\) pour \\( n \\geq 2 \\). Donc \\( n \\leq n \\cdot \\log\_2 n \\) pour \\( n \\geq 2 \\), avec \\( c = 1 \\) et \\( n\_0 = 2 \\).

Pour \\( O(n \\log n) \\subseteq O(n^2) \\) : pour \\( g(n) = n \\log\_2 n \\), notons que \\( \\log\_2 n \\leq n \\) pour \\( n \\geq 1 \\) (comme ci-dessus). Il suit que \\( n \\log\_2 n \\leq n \\cdot n = n^2 \\), avec \\( c = 1 \\) et \\( n\_0 = 1 \\).

Utilisez l’application suivante pour comprendre la différence entre \\(\\log n\\), \\(\\n\\), \\(\\n log n\\) et \\(n^2\\). Assurez-vous d’avoir une bonne intuition concernant la forme de ces fonctions.

Max n:  5

1 (constante)

log n

n (linéaire)

n log n

n² (quadratique)

(function(){const i=document.getElementById("graph");if(!i)return;const e=i.getContext("2d"),r=i.width,a=i.height,t={top:40,right:60,bottom:60,left:80},c=r-t.left-t.right,o=a-t.top-t.bottom,n=2;let s=5;const d=document.getElementById("nMaxSlider"),u=document.getElementById("nMaxValue");d.addEventListener("input",function(){s=parseInt(this.value),u.textContent=s,l()});function l(){e.clearRect(0,0,r,a);const i=s\*s;function d(e){return t.left+(e-n)/(s-n)\*c}function u(e){return t.top+o\*(1-e/i)}e.strokeStyle="#000",e.lineWidth=1,e.beginPath(),e.moveTo(t.left,t.top+o),e.lineTo(t.left+c,t.top+o),e.stroke(),e.beginPath(),e.moveTo(t.left,t.top),e.lineTo(t.left,t.top+o),e.stroke(),e.font="16px sans-serif",e.textAlign="center",e.textBaseline="top";const h=\[n,n+(s-n)/4,n+2\*(s-n)/4,n+3\*(s-n)/4,s\];h.forEach(i=>{if(i>=n&&i<=s){const n=d(i);e.fillText(Math.round(i),n,t.top+o+10),e.beginPath(),e.moveTo(n,t.top+o),e.lineTo(n,t.top+o+5),e.stroke()}}),e.textAlign="right",e.textBaseline="middle";const m=\[0,i/4,i/2,3\*i/4,i\];m.forEach(n=>{const s=u(n);e.fillText(Math.round(n),t.left-10,s),e.beginPath(),e.moveTo(t.left-5,s),e.lineTo(t.left,s),e.stroke()}),e.textAlign="center",e.textBaseline="top",e.fillText("n",r/2,a-20),e.save(),e.translate(20,a/2),e.rotate(-Math.PI/2),e.textAlign="center",e.textBaseline="bottom",e.fillText("valeur de la fonction",0,0),e.restore();function l(t,o){e.strokeStyle=t,e.lineWidth=3,e.beginPath();let a=!0;const r=Math.max(1,(s-n)/1e3);for(let t=Math.max(1,n);t<=s;t+=r){const c=o(t);if(!isNaN(c)&&c>=0&&c<=i){const n=d(t),s=u(c);a?(e.moveTo(n,s),a=!1):e.lineTo(n,s)}}e.stroke()}l("#2ca02c",()=>1),l("#1f77b4",e=>Math.log(e)),l("#ff7f0e",e=>e),l("#d62728",e=>e\*Math.log(e)),l("#9467bd",e=>e\*e)}l()})()

### Exemples d’algorithmes en \\( O(n) \\) [#](#exemples-dalgorithmes-en)

Un algorithme est en \\( O(n) \\) si le nombre d’opérations croît linéairement avec la taille de l’entrée. Par exemple, parcourir un tableau pour calculer la somme de ses éléments :

    somme = 0
    POUR i de 0 à n-1
        somme = somme + tableau[i]
    FIN POUR
    

Une variable somme est initialisée à 0 pour accumuler le résultat. La boucle (POUR i de 0 à n-1) parcourt chaque indice i du tableau, et à chaque itération, la valeur de l’élément tableau\[i\] est ajoutée à somme (`somme = somme + tableau[i]`). À la fin de la boucle, somme contient la somme totale des éléments du tableau.

Ici, chaque élément est visité une seule fois, donc le temps d’exécution est proportionnel à \\( n \\).

### Exemples d’algorithmes en \\( O(n^2) \\) [#](#exemples-dalgorithmes-en-1)

Un algorithme est en \\( O(n^2) \\) si le nombre d’opérations croît comme le carré de la taille de l’entrée. C’est typique des algorithmes qui utilisent deux boucles imbriquées, comme la recherche de toutes les paires d’éléments dans un tableau :

    POUR i de 0 à n-1
        POUR j de 0 à n-1
            faire quelque chose avec tableau[i] et tableau[j]
        FIN POUR
    FIN POUR
    

Ce pseudocode décrit une double boucle imbriquée qui parcourt toutes les paires possibles d’éléments dans un tableau de taille n. La boucle externe (POUR i de 0 à n-1) itère sur chaque indice i du tableau, tandis que la boucle interne (POUR j de 0 à n-1) parcourt à nouveau tous les indices j du tableau, indépendamment de i. À chaque itération, une opération (désignée par « faire quelque chose ») est effectuée en utilisant les éléments `tableau[i]` et `tableau[j]`. Cela inclut les cas où i et j désignent le même élément (quand i = j) ainsi que toutes les combinaisons de paires, y compris les permutations (par exemple, (i,j) et (j,i)).

Ici, pour chaque valeur de \\( i \\), on parcourt toutes les valeurs de \\( j \\), ce qui donne \\( n \\times n = n^2 \\) opérations.

Un algorithme \\( O(n^2) \\) est plus _lent_ qu’un algorithme \\( O(n) \\) quand \\( n \\) est très grand.

### Recherche dans un tableau trié [#](#recherche-dans-un-tableau-tri%c3%a9)

Lorsqu’un tableau est trié, on peut utiliser la recherche dichotomique (ou recherche binaire) pour trouver rapidement un élément. Cette méthode consiste à comparer la valeur recherchée à l’élément du milieu du tableau : si la valeur est plus petite, on recommence la recherche dans la moitié gauche ; sinon, dans la moitié droite. On répète jusqu’à trouver l’élément ou à épuiser le tableau.

Voici un exemple de pseudocode pour la recherche binaire :

    DEBUT
        debut ← 0
        fin ← n - 1
        TANT QUE debut ≤ fin
            milieu ← (debut + fin) // 2
            SI tableau[milieu] == valeur
                retourner VRAI
            SINON SI tableau[milieu] < valeur
                debut ← milieu + 1
            SINON
                fin ← milieu - 1
            FIN SI
        FIN TANT QUE
        retourner FAUX
    FIN
    

Le pseudocode décrit ce processus : on initialise deux indices, debut (0) et fin (n-1), délimitant la partie du tableau à explorer. À chaque itération, on calcule l’indice milieu (moyenne de debut et fin) et compare l’élément à cet indice (`tableau[milieu]`) avec la valeur recherchée. Si les deux sont égaux, l’élément est trouvé (retourner VRAI). Si la valeur est plus grande, la recherche se poursuit dans la moitié droite en ajustant debut à milieu + 1 ; sinon, dans la moitié gauche en ajustant fin à milieu - 1. Le processus se répète tant que debut ≤ fin. Si l’intervalle est épuisé sans trouver la valeur, l’algorithme retourne FAUX, indiquant que l’élément n’est pas dans le tableau.

Pour mieux comprendre l’algorithme, essayez de chercher des nombres dans un tableau trié avec l’application suivante.

 Rechercher

Entrez un nombre et cliquez sur "Rechercher" pour voir les étapes de la recherche binaire.

const sortedArray=\[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37\],arrayContainer=document.getElementById("arrayContainer");function renderArray(e=-1,t=-1,n=-1){arrayContainer.innerHTML="",sortedArray.forEach((s,o)=>{const i=document.createElement("span");i.innerText=s,i.style.padding="1px 10px",i.style.border="1px solid #ccc",i.style.borderRadius="1px",i.style.fontSize="12px",i.style.backgroundColor=o===n?"#ffc107":o>=e&&o<=t&&e!==-1&&t!==-1?"#d4edda":"#fff",i.style.transition="background-color 0.5s",arrayContainer.appendChild(i)})}renderArray();async function performBinarySearch(){const t=parseInt(document.getElementById("searchInput").value),c=document.getElementById("stepsContainer"),n=document.getElementById("resultContainer");if(c.innerHTML="",n.innerHTML="",renderArray(),isNaN(t)){n.innerHTML="Veuillez entrer un nombre valide.";return}let s=0,o=sortedArray.length-1,e=\[\],a=!1,r=-1,i=-1;for(;s<=o;){const n=Math.floor((s+o)/2),c=sortedArray\[n\];if(e.push(\`Comparaison avec l'élément au milieu (index ${n}) : ${c}\`),renderArray(s,o,n),addStepToContainer(e\[e.length-1\]),await new Promise(e=>setTimeout(e,1e3)),c===t){a=!0,r=n,e.push(\`Valeur ${t} trouvée à l'index ${n}.\`),addStepToContainer(e\[e.length-1\]);break}c<t?(e.push(\`La valeur ${t} est plus grande, recherche dans la moitié droite.\`),addStepToContainer(e\[e.length-1\]),i=n,s=n+1):(e.push(\`La valeur ${t} est plus petite, recherche dans la moitié gauche.\`),addStepToContainer(e\[e.length-1\]),o=n-1),await new Promise(e=>setTimeout(e,500))}await new Promise(e=>setTimeout(e,500)),a?(n.innerHTML=\`Valeur ${t} trouvée à l'index ${r}.\`,n.style.color="#28a745"):(i!==-1?n.innerHTML=\`Valeur ${t} non trouvée. La plus grande valeur inférieure est ${sortedArray\[i\]} à l'index ${i}.\`:n.innerHTML=\`Valeur ${t} non trouvée. Aucune valeur inférieure dans le tableau.\`,n.style.color="#dc3545")}function addStepToContainer(e){const t=document.createElement("p");t.innerText=e,t.style.margin="5px 0",t.style.color="#555",document.getElementById("stepsContainer").appendChild(t)}

Observez comment vous faites toujours moins de recherche qu’il y a d’éléments dans le tableau. Pouvez-vous faire en sorte qu’une seule étape soit nécessaire ? Quel est le nombre maximal d’étapes nécessaires ?

Cet algorithme a une complexité en \\( O(\\log n) \\), ce qui le rend très efficace pour les grands tableaux triés. Cela signifie que le nombre d’opérations nécessaires pour trouver (ou ne pas trouver) un élément ne croît pas proportionnellement à la taille du tableau, mais beaucoup plus lentement. Par exemple, pour un tableau de 1 000 000 d’éléments, la recherche binaire nécessite au maximum environ 20 comparaisons (car \\( \\log\_2 1\\,000\\,000 \\approx 20 \\)), alors qu’une recherche linéaire pourrait en demander jusqu’à 1 000 000 dans le pire cas. Plus le tableau est grand, plus l’avantage de la recherche binaire est important.

À chaque étape de la recherche binaire, on divise le nombre d’éléments restants par deux. Si on commence avec \\( n \\) éléments, après une comparaison il en reste \\( n/2 \\), puis \\( n/4 \\), puis \\( n/8 \\), etc. On répète ce processus jusqu’à ce qu’il ne reste qu’un seul élément à examiner.

On cherche donc le nombre d’étapes \\( k \\) tel que :

\\\[ \\frac{n}{2^k} = 1 \\\]

En résolvant pour \\( k \\) :

\\\[ n = 2^k \\implies k = \\log\_2 n \\\]

Ainsi, le nombre maximal de comparaisons est proportionnel à \\( \\log\_2 n \\). C’est pourquoi on dit que la recherche binaire a une complexité en \\( O(\\log n) \\).

### Tri [#](#tri)

Le tri consiste à réorganiser les éléments d’un tableau ou d’une liste selon un ordre donné (par exemple, croissant). Un algorithme de tri naïf, comme le tri à bulles (bubble sort) ou le tri par insertion, compare chaque élément à tous les autres et échange leur position si nécessaire. Ces algorithmes effectuent environ \\( n^2 \\) comparaisons pour un tableau de taille \\( n \\), ce qui leur donne une complexité en \\( O(n^2) \\). Cela devient très lent dès que le nombre d’éléments augmente.

Pseudocode du tri à bulle:

    POUR i de 0 à n-2
        POUR j de 0 à n-2-i
            SI tableau[j] > tableau[j+1] ALORS
                échanger tableau[j] et tableau[j+1]
            FIN SI
        FIN POUR
    FIN POUR
    

Le tri à bulle est un algorithme de tri simple qui parcourt un tableau de manière répétée pour comparer et échanger les éléments adjacents s’ils sont dans le mauvais ordre. Dans le pseudocode présenté, la boucle externe (i de 0 à n-2) contrôle le nombre de passes sur le tableau, chaque passe garantissant que l’élément le plus grand non encore trié est placé à la fin. La boucle interne (j de 0 à n-2-i) compare chaque paire d’éléments consécutifs (tableau\[j\] et tableau\[j+1\]) et les échange s’ils sont mal ordonnés (tableau\[j\] > tableau\[j+1\]). À chaque itération, les éléments les plus grands “remontent” comme des bulles vers la fin du tableau, d’où le nom de l’algorithme.

Utilisez cette application pour mieux comprendre le tri à bulle.

Lancer le tri Réinitialiser

(function(){const t=document.getElementById("bubbleSortApp\_startButton"),a=document.getElementById("bubbleSortApp\_resetButton"),o=document.getElementById("bubbleSortApp\_arrayContainer");let e=\[\],n=!1;function i(){e=Array.from({length:64},()=>Math.floor(Math.random()\*100)+10),s()}function s(t=\[\],n=\[\]){o.innerHTML="",e.forEach((e,s)=>{const i=document.createElement("div");i.style.height=\`${e\*2}px\`,i.style.width="20px",i.style.backgroundColor=t.includes(s)?"red":n.includes(s)?"blue":"gray",i.style.display="inline-block",o.appendChild(i)})}async function r(){if(n)return;n=!0,t.disabled=!0,t.style.cursor="not-allowed";for(let t=0;t<e.length;t++)for(let n=0;n<e.length-t-1;n++)s(\[n,n+1\]),await new Promise(e=>setTimeout(e,100)),e\[n\]>e\[n+1\]&&(\[e\[n\],e\[n+1\]\]=\[e\[n+1\],e\[n\]\],s(\[\],\[n,n+1\]),await new Promise(e=>setTimeout(e,100)));s(),n=!1,t.disabled=!1,t.style.cursor="pointer"}t.addEventListener("click",r),a.addEventListener("click",()=>{n||i()}),i()})()

Un autre algorithme simple est le tri par insertion. Il parcourt le tableau élément par élément, insérant chaque nouvel élément à sa place dans la partie déjà triée.

    POUR i de 1 à n-1
        clé ← tableau[i]
        j ← i - 1
        TANT QUE j ≥ 0 ET tableau[j] > clé
            tableau[j+1] ← tableau[j]
            j ← j - 1
        FIN TANT QUE
        tableau[j+1] ← clé
    FIN POUR
    

Le tri par insertion est un algorithme de tri qui construit progressivement une partie triée du tableau en insérant chaque élément à sa position correcte. Dans le pseudocode fourni, la boucle externe (i de 1 à n-1) sélectionne chaque élément (`clé ← tableau[i]`) à partir du deuxième élément. La boucle interne compare cette clé avec les éléments de la partie déjà triée (de `j ← i-1` jusqu’à 0), en déplaçant les éléments plus grands que la clé d’une position vers la droite (`tableau[j+1] ← tableau[j]`) tant que `tableau[j] > clé` et `j ≥ 0`. Une fois la bonne position trouvée, la clé est insérée (`tableau[j+1] ← clé`). Ce processus répété garantit que, à chaque étape, la sous-partie du tableau jusqu’à l’indice i est triée, aboutissant à un tableau entièrement trié à la fin.

Utilisez cette application pour mieux comprendre le tri par insertion.

Lancer le tri Réinitialiser

(function(){const t=document.getElementById("insertionSortApp\_startButton"),a=document.getElementById("insertionSortApp\_resetButton"),o=document.getElementById("insertionSortApp\_arrayContainer");let e=\[\],s=!1;function i(){e=Array.from({length:64},()=>Math.floor(Math.random()\*100)+10),n()}function n(t=-1,n=\[\]){o.innerHTML="",e.forEach((e,s)=>{const i=document.createElement("div");i.style.height=\`${e\*2}px\`,i.style.width="20px",i.style.backgroundColor=s===t?"blue":n.includes(s)?"red":"gray",i.style.display="inline-block",o.appendChild(i)})}async function r(){if(s)return;s=!0,t.disabled=!0,t.style.cursor="not-allowed";for(let s=1;s<e.length;s++){let o=e\[s\],t=s-1;for(n(s),await new Promise(e=>setTimeout(e,100));t>=0&&e\[t\]>o;)n(s,\[t\]),await new Promise(e=>setTimeout(e,100)),e\[t+1\]=e\[t\],t--;e\[t+1\]=o,n(),await new Promise(e=>setTimeout(e,100))}n(),s=!1,t.disabled=!1,t.style.cursor="pointer"}t.addEventListener("click",r),a.addEventListener("click",()=>{s||i()}),i()})()

Heureusement, il existe des algorithmes de tri plus efficaces. Par exemple, le tri fusion (merge sort) utilise une approche « diviser pour régner » : il divise le tableau en deux moitiés, trie chaque moitié récursivement, puis fusionne les deux moitiés triées en un seul tableau trié. Cette méthode réduit considérablement le nombre de comparaisons nécessaires et atteint une complexité en \\( O(n \\log n) \\).

Idée générale du trie fusion :

1.  Si le tableau contient 0 ou 1 élément, il est déjà trié.
2.  Sinon, on divise le tableau en deux parties de taille à peu près égale.
3.  On trie récursivement chaque partie.
4.  On fusionne les deux parties triées pour obtenir un tableau final trié.

Pseudocode du tri fusion:

    FONCTION triFusion(tableau)
        SI taille(tableau) ≤ 1 ALORS
            retourner tableau
        FIN SI
        milieu ← taille(tableau) // 2
        gauche ← triFusion(tableau[0 .. milieu-1])
        droite ← triFusion(tableau[milieu .. fin])
        retourner fusionner(gauche, droite)
    FIN FONCTION
    
    FONCTION fusionner(gauche, droite)
        résultat ← tableau vide
        TANT QUE gauche et droite ne sont pas vides
            SI gauche[0] ≤ droite[0] ALORS
                ajouter gauche[0] à résultat
                retirer gauche[0] de gauche
            SINON
                ajouter droite[0] à résultat
                retirer droite[0] de droite
            FIN SI
        FIN TANT QUE
        ajouter le reste de gauche (s’il en reste) à résultat
        ajouter le reste de droite (s’il en reste) à résultat
        retourner résultat
    FIN FONCTION
    

Le pseudocode décrit deux fonctions principales. La fonction triFusion divise récursivement le tableau en deux moitiés jusqu’à ce que chaque sous-tableau ait au plus un élément (déjà trié). Pour cela, elle calcule l’indice milieu, trie récursivement la moitié gauche (0 à milieu-1) et la moitié droite (milieu à fin), puis fusionne ces deux sous-tableaux triés. La fonction fusionner combine les sous-tableaux gauche et droite en un tableau trié : elle compare les premiers éléments de chaque sous-tableau, ajoute le plus petit à résultat, et retire cet élément de son sous-tableau d’origine. Ce processus continue jusqu’à ce qu’un des sous-tableaux soit vide, puis les éléments restants de l’autre sous-tableau sont ajoutés à résultat.

Le tri fusion est donc beaucoup plus rapide que les tris naïfs pour les grands tableaux, et il illustre l’intérêt des algorithmes efficaces en informatique.

Utilisez cette application pour mieux comprendre le tri fusion.

Lancer le tri Réinitialiser

(function(){const n=document.getElementById("mergeSortApp\_startButton"),r=document.getElementById("mergeSortApp\_resetButton"),i=document.getElementById("mergeSortApp\_arrayContainer");let e=\[\],s=!1;function a(){e=Array.from({length:64},()=>Math.floor(Math.random()\*100)+10),t()}function t(t=\[\],n=\[\]){i.innerHTML="",e.forEach((e,s)=>{const o=document.createElement("div");o.style.height=\`${e\*2}px\`,o.style.width="20px",o.style.backgroundColor=n.includes(s)?"blue":t.includes(s)?"red":"gray",o.style.display="inline-block",i.appendChild(o)})}async function c(n,s,o){let c=\[\],a=0,r=0,i=o;for(;a<n.length&&r<s.length;)t(\[i\],\[i\]),await new Promise(e=>setTimeout(e,100)),n\[a\]<=s\[r\]?(c.push(n\[a\]),e\[i\]=n\[a\],a++):(c.push(s\[r\]),e\[i\]=s\[r\],r++),i++,t(\[o,o+c.length-1\],\[i-1\]),await new Promise(e=>setTimeout(e,100));for(;a<n.length;)c.push(n\[a\]),e\[i\]=n\[a\],t(\[i\],\[i\]),await new Promise(e=>setTimeout(e,100)),a++,i++;for(;r<s.length;)c.push(s\[r\]),e\[i\]=s\[r\],t(\[i\],\[i\]),await new Promise(e=>setTimeout(e,100)),r++,i++;return c}async function o(n,s){if(n<s){const i=Math.floor((n+s)/2);t(e.slice(n,i+1).map((e,t)=>n+t)),await new Promise(e=>setTimeout(e,100)),await o(n,i),t(e.slice(i+1,s+1).map((e,t)=>i+1+t)),await new Promise(e=>setTimeout(e,100)),await o(i+1,s);const a=e.slice(n,i+1),r=e.slice(i+1,s+1);await c(a,r,n)}}async function l(){if(s)return;s=!0,n.disabled=!0,n.style.cursor="not-allowed",await o(0,e.length-1),t(),s=!1,n.disabled=!1,n.style.cursor="pointer"}n.addEventListener("click",l),r.addEventListener("click",()=>{s||a()}),a()})()

Un autre algorithme performant est le tri rapide (quick sort). Il choisit un élément pivot, partitionne le tableau en deux sous-tableaux (les éléments plus petits que le pivot et ceux plus grands), puis trie récursivement chaque sous-tableau. En moyenne, sa complexité est en \\( O(n \\log n) \\), bien qu’il puisse atteindre \\( O(n^2) \\) dans le pire cas (par exemple, si le tableau est déjà trié et que le pivot est mal choisi). Le choix du pivot est crucial : une stratégie courante est de sélectionner la médiane de trois valeurs ou un élément aléatoire.

    FONCTION triRapide(tableau, début, fin)
        SI début < fin ALORS
            pivot ← partitionner(tableau, début, fin)
            triRapide(tableau, début, pivot - 1)
            triRapide(tableau, pivot + 1, fin)
        FIN SI
    FIN FONCTION
    
    FONCTION partitionner(tableau, début, fin)
        pivot ← tableau[fin]
        i ← début - 1
        POUR j de début à fin - 1
            SI tableau[j] ≤ pivot ALORS
                i ← i + 1
                échanger tableau[i] et tableau[j]
            FIN SI
        FIN POUR
        échanger tableau[i + 1] et tableau[fin]
        retourner i + 1
    FIN FONCTION
    

La fonction triRapide vérifie si l’intervalle à trier (de début à fin) contient plus d’un élément ; si oui, elle appelle partitionner pour réorganiser le tableau autour d’un pivot, puis trie récursivement les sous-tableaux à gauche (de début à pivot-1) et à droite (de pivot+1 à fin). La fonction partitionner sélectionne le dernier élément comme pivot (tableau\[fin\]) et réarrange le tableau de sorte que les éléments inférieurs ou égaux au pivot soient à gauche et les plus grands à droite. Elle utilise un indice i pour suivre la frontière des éléments plus petits et échange les éléments appropriés via un parcours (j de début à fin-1). Enfin, le pivot est placé à sa position finale (échange avec tableau\[i+1\]), et son indice (i+1) est retourné.

Utilisez cette application pour mieux comprendre le tri rapide.

Stratégie de pivot : Médiane de troisÉlément aléatoireDernier élémentPremier élément Lancer le tri Réinitialiser

(function(){const n=document.getElementById("quickSortApp\_startButton"),r=document.getElementById("quickSortApp\_resetButton"),c=document.getElementById("quickSortApp\_pivotStrategy"),i=document.getElementById("quickSortApp\_arrayContainer");let e=\[\],s=!1;function a(){e=Array.from({length:64},()=>Math.floor(Math.random()\*100)+10),t()}function t(t=-1,n=\[\],s=\[\]){i.innerHTML="",e.forEach((e,o)=>{const a=document.createElement("div");a.style.height=\`${e\*2}px\`,a.style.width="20px",a.style.backgroundColor=o===t?"green":s.includes(o)?"blue":n.includes(o)?"red":"gray",a.style.display="inline-block",i.appendChild(a)})}function l(t,n){const s=Math.floor((t+n)/2),o=\[{value:e\[t\],index:t},{value:e\[s\],index:s},{value:e\[n\],index:n}\];return o.sort((e,t)=>e.value-t.value),o\[1\].index}async function d(n,s){let o;const a=c.value;a==="first"?o=n:a==="random"?o=n+Math.floor(Math.random()\*(s-n+1)):a==="median"?o=l(n,s):o=s;const r=e\[o\];o!==s&&(\[e\[o\],e\[s\]\]=\[e\[s\],e\[o\]\],o=s),t(o,\[n,s\]),await new Promise(e=>setTimeout(e,100));let i=n-1;for(let a=n;a<s;a++)t(o,\[a,i+1\]),await new Promise(e=>setTimeout(e,100)),e\[a\]<=r&&(i++,i!==a&&(\[e\[i\],e\[a\]\]=\[e\[a\],e\[i\]\],t(o,\[\],\[i,a\]),await new Promise(e=>setTimeout(e,100))));return i+1!==s&&(\[e\[i+1\],e\[s\]\]=\[e\[s\],e\[i+1\]\],t(-1,\[\],\[i+1,s\]),await new Promise(e=>setTimeout(e,100))),i+1}async function o(e,t){if(e<t){const n=await d(e,t);await o(e,n-1),await o(n+1,t)}}async function u(){if(s)return;s=!0,n.disabled=!0,n.style.cursor="not-allowed",await o(0,e.length-1),t(),s=!1,n.disabled=!1,n.style.cursor="pointer"}n.addEventListener("click",u),r.addEventListener("click",()=>{s||a()}),a()})()

Le tri rapide est souvent le plus rapide en pratique pour plusieurs raisons. Premièrement, le tri rapide est efficace en termes de localité de mémoire. Il travaille directement sur le tableau (tri en place), ce qui minimise les accès mémoire et exploite bien la mémoire tampon des processeurs modernes. Comparé au tri fusion, qui nécessite un tableau auxiliaire pour la fusion, le tri rapide réduit les allocations de mémoire et les copies d’éléments. Deuxièmement, le tri rapide effectue moins de comparaisons en moyenne. Lors du partitionnement, il répartit les éléments autour d’un pivot, ce qui réduit rapidement la taille des sous-tableaux à trier. Si le pivot est bien choisi (par exemple, proche de la médiane), les sous-tableaux sont équilibrés, conduisant à une division efficace du problème. Même avec un choix de pivot aléatoire, les cas défavorables sont rares dans des données réelles. Troisièmement, le tri rapide est adaptable aux données. Dans des ensembles partiellement triés ou avec des motifs courants, il peut tirer parti de ces structures pour réduire le nombre d’échanges. Par exemple, un bon choix de pivot peut minimiser les réarrangements inutiles.

Utilisez l’application suivante pour comparer les techniques de tri. Appuyez sur _Lancer tous les tris_ et regardez les 4 algorithmes s’exécuter en même temps. Constatez que certains algorithmes sont plus rapides que d’autres. Que pensez-vous qu’il se passerait si nous avions moins d’éléments (par ex., 4) ou beaucoup plus d’éléments (par ex., 1000) ?

Lancer tous les tris Réinitialiser Stratégie de pivot (tri rapide) : Médiane de troisÉlément aléatoireDernier élémentPremier élément

Tri à bulles

Tri par insertion

Tri par fusion

Tri rapide

(function(){const i=document.getElementById("sortingApp\_startAllButton"),f=document.getElementById("sortingApp\_resetButton"),m=document.getElementById("sortingApp\_pivotStrategy"),c={bubble:document.getElementById("sortingApp\_bubbleSortContainer"),insertion:document.getElementById("sortingApp\_insertionSortContainer"),merge:document.getElementById("sortingApp\_mergeSortContainer"),quick:document.getElementById("sortingApp\_quickSortContainer")};let a=\[\],t={bubble:\[\],insertion:\[\],merge:\[\],quick:\[\]},r=!1,o={bubble:new Set,insertion:new Set,merge:new Set,quick:new Set};const j=64,s=50,w=100,p=10;function d(){a=Array.from({length:j},()=>Math.floor(Math.random()\*(w-p+1))+p),t.bubble=\[...a\],t.insertion=\[...a\],t.merge=\[...a\],t.quick=\[...a\],o={bubble:new Set,insertion:new Set,merge:new Set,quick:new Set},e()}function l(e,t,n,s={comparing:\[\],swapping:\[\],pivot:-1}){e.innerHTML="";const i=e.clientWidth-2\*10,a=2,r=(t.length-1)\*a,c=Math.max(2,Math.floor((i-r)/t.length));t.forEach((t,i)=>{const a=document.createElement("div");a.style.transition="background-color 0.1s ease, height 0.1s ease",a.style.display="inline-block",a.style.borderRadius="4px",a.style.height=\`${t\*2}px\`,a.style.width=\`${c}px\`,o\[n\].has(i)?a.style.backgroundColor="#10b981":i===s.pivot?a.style.backgroundColor="#22c55e":Array.isArray(s.swapping)&&s.swapping.includes(i)?a.style.backgroundColor="#3b82f6":Array.isArray(s.comparing)&&s.comparing.includes(i)?a.style.backgroundColor="#ef4444":a.style.backgroundColor="#6b7280",e.appendChild(a)})}function e(e={}){l(c.bubble,t.bubble,"bubble",{comparing:\[\],swapping:\[\],pivot:-1,...e.bubble}),l(c.insertion,t.insertion,"insertion",{comparing:\[\],swapping:\[\],pivot:-1,...e.insertion}),l(c.merge,t.merge,"merge",{comparing:\[\],swapping:\[\],pivot:-1,...e.merge}),l(c.quick,t.quick,"quick",{comparing:\[\],swapping:\[\],pivot:-1,...e.quick})}const n=e=>new Promise(t=>setTimeout(t,e));async function v(){let i=t.bubble,a=i.length;for(let t=0;t<a-1;t++){for(let o=0;o<a-t-1;o++)e({bubble:{comparing:\[o,o+1\]}}),await n(s),i\[o\]>i\[o+1\]&&(\[i\[o\],i\[o+1\]\]=\[i\[o+1\],i\[o\]\],e({bubble:{swapping:\[o,o+1\]}}),await n(s));o.bubble.add(a-1-t)}o.bubble.add(0),e({bubble:{}})}async function g(){let i=t.insertion,a=i.length;for(let r=1;r<a;r++){let c=i\[r\],t=r-1;for(e({insertion:{comparing:\[r\],swapping:\[t+1\]}}),await n(s);t>=0&&i\[t\]>c;)i\[t+1\]=i\[t\],e({insertion:{comparing:\[t,r\],swapping:\[t+1,t\]}}),await n(s),t--;i\[t+1\]=c,e({insertion:{swapping:\[t+1\]}}),await n(s);for(let e=0;e<=r;e++)o.insertion.add(e)}for(let e=0;e<a;e++)o.insertion.add(e);e({insertion:{}})}async function b(t,o,i,a){let r=\[\],c=o,l=i+1,d=0;for(;c<=i&&l<=a;)e({merge:{comparing:\[c,l\]}}),await n(s),t\[c\]<=t\[l\]?r\[d++\]=t\[c++\]:r\[d++\]=t\[l++\];for(;c<=i;)r\[d++\]=t\[c++\];for(;l<=a;)r\[d++\]=t\[l++\];for(let i=0;i<r.length;i++)t\[o+i\]=r\[i\],e({merge:{swapping:\[o+i\]}}),await n(s)}async function h(t,n,s){if(n>=s){n===s&&o.merge.add(n);return}const i=Math.floor((n+s)/2);await h(t,n,i),await h(t,i+1,s),await b(t,n,i,s);for(let e=n;e<=s;e++)o.merge.add(e);e({merge:{}})}async function y(e,t,n){const s=Math.floor((t+n)/2),o=\[{value:e\[t\],index:t},{value:e\[s\],index:s},{value:e\[n\],index:n}\];return o.sort((e,t)=>e.value-t.value),o\[1\].index}async function \_(t,o,i){let c;const l=m.value;l==="first"?c=o:l==="random"?c=o+Math.floor(Math.random()\*(i-o+1)):l==="median"?c=await y(t,o,i):c=i,\[t\[c\],t\[i\]\]=\[t\[i\],t\[c\]\];let r=i;const d=t\[r\];e({quick:{pivot:r,comparing:\[o,i\]}}),await n(s);let a=o-1;for(let c=o;c<i;c++)e({quick:{pivot:r,comparing:\[c,a+1\]}}),await n(s),t\[c\]<d&&(a++,a!==c&&(\[t\[a\],t\[c\]\]=\[t\[c\],t\[a\]\],e({quick:{pivot:r,swapping:\[a,c\]}}),await n(s)));return a+1!==r&&(\[t\[a+1\],t\[r\]\]=\[t\[r\],t\[a+1\]\],e({quick:{swapping:\[a+1,r\]}}),await n(s)),a+1}async function u(t,n,s){if(n<s){const e=await \_(t,n,s);await u(t,n,e-1),await u(t,e+1,s),o.quick.add(e)}else n===s&&o.quick.add(n);e({quick:{}})}async function O(){if(r)return;r=!0,i.disabled=!0,i.style.cursor="not-allowed",i.style.opacity="0.7",f.disabled=!0,m.disabled=!0,d(),console.log("Starting all sorts concurrently..."),await Promise.all(\[v(),g(),h(t.merge,0,t.merge.length-1),u(t.quick,0,t.quick.length-1)\]),console.log("All sorts finished."),r=!1,i.disabled=!1,i.style.cursor="pointer",i.style.opacity="1",f.disabled=!1,m.disabled=!1}i.addEventListener("click",O),f.addEventListener("click",()=>{r||d()}),d(),window.addEventListener("resize",()=>{r||e()})})()

Le Java utilise généralement Timsort. Timsort est un algorithme de tri hybride, conçu par Tim Peters. Il combine le tri par insertion et le tri fusion pour optimiser les performances sur des données réelles, en exploitant les séquences déjà triées, appelées _runs_. L’algorithme commence par diviser le tableau en petits _runs_, soit naturels (séquences croissantes ou décroissantes), soit créés en triant des blocs de taille minimale (souvent 32 éléments) avec le tri par insertion. Ces _runs_ sont ensuite fusionnés deux à deux à l’aide d’une version optimisée du tri fusion, qui minimise les comparaisons et les copies. Sa complexité est en \\( O(n \\log n) \\) dans le pire cas, mais elle peut descendre à \\( O(n) \\) pour des données presque triées, rendant Timsort particulièrement efficace en pratique. De plus, Timsort est stable, préservant l’ordre relatif des éléments égaux, ce qui est crucial dans certaines applications.

Dans certains cas spécialisés, nous utilisons l’algorithme de tri par niches, également connu sous le nom de _pigeonhole sort_, est un algorithme de tri non comparatif adapté aux ensembles de données où les éléments appartiennent à un ensemble fini de valeurs entières, comme des nombres dans une plage limitée. Il repose sur le principe des “niches” (ou pigeonholes) : chaque valeur possible est associée à une niche, et les éléments sont placés dans la niche correspondant à leur valeur. Ensuite, les niches sont parcourues dans l’ordre pour reconstruire le tableau trié. Sa complexité est en \\( O(n + k) \\), où \\( n \\) est le nombre d’éléments et \\( k \\) la taille de la plage de valeurs. Cet algorithme est très efficace lorsque \\( k \\) est proche de \\( n \\), mais il nécessite un espace auxiliaire proportionnel à \\( k \\) et n’est pas adapté aux données non entières ou à des plages de valeurs très grandes.

    FONCTION triParNiches(tableau, min, max)
        k ← max - min + 1  // Taille de la plage de valeurs
        niches ← tableau de taille k, initialisé à vide
    
        // Étape 1 : placer les éléments dans les niches
        POUR chaque élément dans tableau
            index ← élément - min
            ajouter élément à niches[index]
        FIN POUR
    
        // Étape 2 : reconstruire le tableau trié
        index ← 0
        POUR i de 0 à k-1
            TANT QUE niches[i] n’est pas vide
                tableau[index] ← premier élément de niches[i]
                retirer premier élément de niches[i]
                index ← index + 1
            FIN TANT QUE
        FIN POUR
    
        retourner tableau
    FIN FONCTION
    

Le tri par niches (ou bucket sort) est un algorithme de tri non comparatif adapté aux données uniformément réparties dans une plage de valeurs connue (de min à max). Le pseudocode décrit un processus en deux étapes. D’abord, il calcule la taille de la plage (k ← max - min + 1) et crée un tableau niches de taille k, où chaque niche correspond à une valeur possible. Dans l’étape 1, chaque élément du tableau est placé dans la niche correspondante (index ← élément - min), ce qui regroupe les éléments de même valeur. Dans l’étape 2, le tableau est reconstruit en parcourant les niches dans l’ordre (de 0 à k-1) et en extrayant leurs éléments pour les placer séquentiellement dans le tableau (tableau\[index\]). L’indice index suit la position d’insertion.

#### Vidéo suggérée [#](#vid%c3%a9o-sugg%c3%a9r%c3%a9e)

### Table de hachage [#](#table-de-hachage)

Une table de hachage (ou « hash table ») est une structure de données qui permet d’associer des clés à des valeurs et d’accéder très rapidement à une valeur à partir de sa clé. Le principe repose sur l’utilisation d’une fonction de hachage qui transforme la clé (par exemple, un texte ou un nombre) en un indice de tableau. Les opérations d’insertion, de recherche et de suppression se font en temps moyen \\( O(1) \\), c’est-à-dire en temps constant, quelle que soit la taille de la table (si la fonction de hachage est bonne et la table bien dimensionnée). La table de hachage est efficace pour retrouver rapidement une information à partir d’une clé.

Idée générale :

1.  On applique une fonction de hachage à la clé pour obtenir un indice.
2.  On stocke la valeur à cet indice dans un tableau.
3.  En cas de « collision » (deux clés différentes qui donnent le même indice), on utilise une technique de résolution (chaînage, sondage linéaire, etc.).

Pseudocode d’une recherche dans une table de hachage (sans collision):

    FONCTION rechercher(table, clé)
        indice ← hachage(clé)
        SI table[indice] == clé ALORS
            retourner VRAI
        SINON
            retourner FAUX
        FIN SI
    FIN FONCTION
    

Le pseudocode décrit une fonction de recherche dans une table de hachage, une structure de données optimisée pour retrouver rapidement un élément. La fonction rechercher prend une table (tableau représentant la table de hachage) et une clé à chercher (clé). Elle commence par calculer l’indice correspondant à la clé via une fonction de hachage (indice ← hachage(clé)), qui mappe la clé à une position dans la table. Ensuite, elle vérifie si l’élément à cet indice (`table[indice]`) est égal à la clé recherchée. Si c’est le cas, la fonction retourne VRAI, indiquant que la clé est présente. Sinon, elle retourne FAUX, signifiant que la clé est absente. Ce pseudocode suppose une table de hachage simple sans gestion des collisions (cas où plusieurs clés pointent vers le même indice), ce qui la rend efficace mais limitée aux cas où chaque indice contient au plus un élément.

Pour mieux comprendre, testez l’application suivante. Saisissez des chaînes de caractères qui seront ajoutées à la table de hachage. Pouvez-vous créer une collision ?

 Ajouter

Chaînes saisies
---------------

Chaîne

Valeur de hachage

Position dans la table

Table de hachage
----------------

(function(){const e="hashApp\_",n=10,t={hashTable:Array(n).fill().map(()=>\[\]),strings:\[\]};function o(t){try{let e=0;for(let n of t)e+=n.charCodeAt(0);const s=e%n;return{hashValue:e,index:s}}catch(t){return console.error(\`${e}Erreur dans hashFunction:\`,t),null}}function i(){try{const i=document.getElementById(\`${e}stringInput\`),n=i.value.trim();if(!n)return;const r=o(n);if(!r)return;const{hashValue:l,index:c}=r;t.strings.push({str:n,hashValue:l,index:c}),t.hashTable\[c\].push(n),a(),s(),i.value=""}catch(t){console.error(\`${e}Erreur dans addString:\`,t)}}function a(){try{const n=document.getElementById(\`${e}stringTableBody\`);n.innerHTML="",t.strings.forEach(({str:e,hashValue:t,index:s})=>{const o=document.createElement("tr");o.innerHTML=\` <td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${e}</td> <td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${t}</td> <td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${s}</td> \`,n.appendChild(o)})}catch(t){console.error(\`${e}Erreur dans updateStringTable:\`,t)}}function s(){try{const s=document.getElementById(\`${e}hashTableDisplay\`);s.innerHTML="";for(let e=0;e<n;e++){const o=document.createElement("div");o.style.cssText="padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9;",o.innerHTML=\`<h3 style="margin: 0; font-size: 16px;">Index ${e}</h3><p>${t.hashTable\[e\].length>0?t.hashTable\[e\].join(", "):"Vide"}</p>\`,s.appendChild(o)}}catch(t){console.error(\`${e}Erreur dans updateHashTableDisplay:\`,t)}}function r(){try{const t=document.getElementById(\`${e}addButton\`);t&&t.addEventListener("click",i),s()}catch(t){console.error(\`${e}Erreur dans init:\`,t)}}r()})().hash-app-container{contain:content;padding:20px;max-width:800px;margin:0 auto}

En Java, la classe `HashMap` que nous verrons plus loin dans le cours implémente une table de hachage. Par exemple :

    import java.util.HashMap;
    
    HashMap<String, Integer> dico = new HashMap<>();
    dico.put("chat", 1);
    dico.put("chien", 2);
    System.out.println(dico.get("chat")); // Affiche 1
    

Ce code Java utilise une HashMap pour créer une structure de données associant des clés à des valeurs. Une instance `HashMap<String, Integer>` est déclarée, avec des clés de type String et des valeurs de type Integer. Deux paires clé-valeur sont ajoutées via la méthode put : “chat” associé à 1 et “chien” à 2. La méthode get(“chat”) récupère la valeur liée à la clé “chat”, soit 1, qui est ensuite affichée avec System.out.println.

Les tables de hachage sont omniprésentes en informatique car elles rendent possible la recherche rapide dans de grands ensembles de données.

Imaginons que l’on souhaite stocker un ensemble de chaînes de caractères de différentes longueurs, par exemple « chat », « chien », « girafe », « lion ». Pour retrouver rapidement une chaîne, on peut utiliser une table de hachage où la fonction de hachage choisie est simplement la longueur de la chaîne. Ainsi, « chat » (4 lettres) sera stocké à l’indice 4, « chien » (5 lettres) à l’indice 5, « girafe » (6 lettres) à l’indice 6, et ainsi de suite. Pour rechercher une chaîne, il suffit de calculer sa longueur et d’aller directement à l’indice correspondant dans le tableau. Cette opération ne dépend pas du nombre total de chaînes stockées, ce qui explique pourquoi la recherche est dite « en temps constant » : on ne parcourt pas toute la table, on accède directement à la bonne case.

Cependant, ce choix de fonction de hachage est très simple et peut provoquer des « collisions » : deux chaînes de même longueur, comme « lion » et « chat », auraient le même indice. Dans ce cas, il faut une méthode pour gérer ces collisions, par exemple en stockant les deux chaînes dans une liste à cet indice. En pratique, les tables de hachage utilisent des fonctions de hachage beaucoup plus sophistiquées, capables de transformer n’importe quelle clé (texte, nombre, etc.) en un indice réparti de façon plus uniforme dans le tableau. L’objectif reste toujours de minimiser les collisions, car tant qu’il y en a peu, la recherche, l’insertion et la suppression restent très rapides et efficaces, même avec de très grands ensembles de données.

#### Vidéo suggérée [#](#vid%c3%a9o-sugg%c3%a9r%c3%a9e-1)

### Un problème résoluble en \\( O(n^2) \\) ou en \\( O(n) \\) [#](#un-probl%c3%a8me-r%c3%a9soluble-en--ou-en)

Prenons le problème suivant : « Trouver s’il existe deux éléments dans un tableau qui, additionnés, donnent une valeur cible. »

Solution naïve (\\( O(n^2) \\)) :

    POUR i de 0 à n-1
        POUR j de i+1 à n-1
            SI tableau[i] + tableau[j] == cible
                retourner VRAI
            FIN SI
        FIN POUR
    FIN POUR
    retourner FAUX
    

La boucle externe (POUR i de 0 à n-1) parcourt chaque élément du tableau, tandis que la boucle interne (POUR j de i+1 à n-1) examine tous les éléments suivants (à partir de i+1) pour éviter de considérer le même élément deux fois ou des paires redondantes. À chaque itération, la condition SI `tableau[i] + tableau[j] == cible` teste si la somme des éléments aux indices i et j égale la valeur cible. Si une telle paire est trouvée, la fonction retourne VRAI, indiquant que la solution existe. Si aucune paire ne satisfait la condition après avoir exploré toutes les combinaisons, la fonction retourne FAUX.

Ici, on teste toutes les paires possibles, ce qui prend un temps quadratique.

Solution optimisée (\\( O(n) \\)) :

On peut résoudre ce problème en temps linéaire en utilisant une structure de données comme un ensemble (set) :

    initialiser un ensemble vide
    POUR chaque élément x du tableau
        SI (cible - x) est dans l’ensemble
            retourner VRAI
        AJOUTER x à l’ensemble
    FIN POUR
    retourner FAUX
    

Initialement, un ensemble vide est créé pour stocker les éléments rencontrés. La boucle (POUR chaque élément x du tableau) parcourt chaque élément x du tableau. Pour chaque x, l’algorithme vérifie si cible - x (la valeur nécessaire pour atteindre la somme cible) est déjà dans l’ensemble. Si c’est le cas, une paire d’éléments dont la somme vaut cible a été trouvée, et la fonction retourne VRAI. Sinon, l’élément x est ajouté à l’ensemble pour être utilisé dans les itérations suivantes. Si la boucle se termine sans trouver une telle paire, la fonction retourne FAUX.

Ici, chaque élément est traité une seule fois, et si la recherche dans l’ensemble se fait en temps constant (en moyenne) ou \\( O(1) \\), la solution est en \\( O(n) \\). Dans la solution optimisée, la vérification « (cible - x) est dans l’ensemble » est cruciale. Il n’est pas garanti que la recherche se fasse en temps \\( O(1) \\), mais c’est possible avec une table de hachage.

### Les arbres en informatique [#](#les-arbres-en-informatique)

Les arbres sont des structures de données hiérarchiques non linéaires, composées de nœuds reliés par des arêtes. Un arbre possède une racine unique, à partir de laquelle descendent des sous-arbres. Chaque nœud peut avoir zéro ou plusieurs enfants, mais un seul parent (sauf la racine). À partir du sommet, nous progressons vers les feuilles qui où se terminent la progression. Les arbres permettent de représenter des relations hiérarchiques naturelles, comme des dossiers dans un système de fichiers, des expressions arithmétiques ou des structures organisationnelles.

Parmi les arbres les plus utilisés figure l’arbre binaire, où chaque nœud a au plus deux enfants (gauche et droit). L’arbre binaire de recherche (ABR) est une variante particulièrement utile : pour tout nœud, les valeurs dans le sous-arbre gauche sont inférieures à celle du nœud, et celles dans le sous-arbre droit sont supérieures. Cela permet des opérations de recherche, insertion et suppression efficaces dans un arbre équilibré.

    fonction rechercher(racine, valeur_cible)
        courant ← racine
        tant que courant n'est pas null
            si valeur_cible = courant.valeur
                retourner courant
            fin si
            
            si valeur_cible < courant.valeur
                courant ← courant.gauche
            sinon
                courant ← courant.droit
            fin si
        fin tant que
        
        retourner null  // valeur non trouvée
    fin fonction
    

Pour mieux comprendre le fonctionnement d’un arbre de recherche binaire, utilisez l’application suivante.

 Insérer Rechercher Supprimer Effacer

class Node{constructor(e){this.value=e,this.left=null,this.right=null,this.x=400,this.y=50}}let root=null;const canvas=document.getElementById("canvas"),ctx=canvas.getContext("2d"),nodeRadius=20;let animating=!1;function buildBalanced(e,t,n){if(t>n)return null;let s=Math.floor((t+n)/2),o=new Node(e\[s\]);return o.left=buildBalanced(e,t,s-1),o.right=buildBalanced(e,s+1,n),o}let values=\[10,20,30,40,50,55,70,80\].sort((e,t)=>e-t);root=buildBalanced(values,0,values.length-1);function drawTree(){ctx.clearRect(0,0,canvas.width,canvas.height),root&&drawNode(root,canvas.width/2,50,canvas.width/4)}function drawNode(e,t,n,s){if(!e)return;e.x=t,e.y=n,e.left&&(ctx.beginPath(),ctx.moveTo(t,n),ctx.lineTo(t-s,n+80),ctx.stroke()),e.right&&(ctx.beginPath(),ctx.moveTo(t,n),ctx.lineTo(t+s,n+80),ctx.stroke()),ctx.fillStyle="#f0f0f0",ctx.beginPath(),ctx.arc(t,n,nodeRadius,0,Math.PI\*2),ctx.fill(),ctx.strokeStyle="#000",ctx.stroke(),ctx.fillStyle="#000",ctx.font="14px sans-serif",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(e.value,t,n),drawNode(e.left,t-s,n+80,s/2),drawNode(e.right,t+s,n+80,s/2)}async function insert(e){if(animating)return;if(animating=!0,e=parseInt(e),isNaN(e)){animating=!1;return}if(!root){root=new Node(e),drawTree(),animating=!1;return}let t=root;for(;!0;)if(ctx.fillStyle="rgba(0, 255, 0, 0.3)",ctx.beginPath(),ctx.arc(t.x,t.y,nodeRadius+5,0,Math.PI\*2),ctx.fill(),drawTree(),e<t.value){if(!t.left){t.left=new Node(e),drawTree();break}t=t.left}else if(e>t.value){if(!t.right){t.right=new Node(e),drawTree();break}t=t.right}else break;animating=!1}async function search(e){if(animating||!root)return;animating=!0,e=parseInt(e);let t=root,n=!1;for(;t;){if(drawTree(),ctx.fillStyle="rgba(255, 255, 0, 0.4)",ctx.beginPath(),ctx.arc(t.x,t.y,nodeRadius+5,0,Math.PI\*2),ctx.fill(),await sleep(800),e===t.value){n=!0,ctx.fillStyle="rgba(0, 255, 0, 0.5)",ctx.beginPath(),ctx.arc(t.x,t.y,nodeRadius+5,0,Math.PI\*2),ctx.fill(),await sleep(1e3),drawTree();break}t=e<t.value?t.left:t.right}n||(alert("Valeur non trouvée"),drawTree()),animating=!1}async function remove(e){if(animating||!root)return;animating=!0,root=await removeNode(root,parseInt(e)),drawTree(),animating=!1}async function removeNode(e,t){if(!e)return null;if(ctx.fillStyle="rgba(255, 255, 0, 0.4)",ctx.beginPath(),ctx.arc(e.x,e.y,nodeRadius+5,0,Math.PI\*2),ctx.fill(),drawTree(),t<e.value)e.left=await removeNode(e.left,t);else if(t>e.value)e.right=await removeNode(e.right,t);else{if(ctx.fillStyle="rgba(255, 0, 0, 0.5)",ctx.beginPath(),ctx.arc(e.x,e.y,nodeRadius+5,0,Math.PI\*2),ctx.fill(),drawTree(),!e.left)return e.right;if(!e.right)return e.left;let t=e.right;for(;t.left;)t=t.left;e.value=t.value,e.right=await removeNode(e.right,t.value)}return e}function sleep(e){return new Promise(t=>setTimeout(t,e))}function insertValue(){const e=document.getElementById("value").value;insert(e)}function searchValue(){const e=document.getElementById("value").value;search(e)}function deleteValue(){const e=document.getElementById("value").value;remove(e)}function clearTree(){root=null,drawTree()}drawTree()

Nous souhaitons garder la distance entre le sommet et les feuilles aussi petite que possible. Cette distance détermine notre complexité de recherche. L’arbre rouge-noir (red-black tree) est une des arbres les plus populaires, utilisée notamment dans les implémentations de Map et Set en Java (TreeMap, TreeSet). Chaque nœud est coloré en rouge ou noir, et l’arbre respecte cinq propriétés strictes : la racine est noire, chaque feuille (nil) est noire, un nœud rouge a des enfants noirs, tout chemin d’un nœud à une feuille contient le même nombre de nœuds noirs, et aucun chemin ne contient deux rouges consécutifs. Ces règles assurent que l’arbre reste approximativement équilibré, avec une hauteur maximale d’environ \\( 2 \\log n \\). Lors d’insertions ou suppressions, des violations de couleur peuvent survenir ; elles sont corrigées par des opérations locales qui maintiennent l’équilibre. Les arbres rouge-noir offrent des performances garanties. Les opérations de recherche, insertion et suppression s’exécutent en \\( O(\\log n) \\) dans le pire cas, où \\( n \\) est le nombre de nœuds. Dans ce cours, il n’est pas nécessaire de concevoir des structures en arbres.

#### Vidéo suggérée [#](#vid%c3%a9o-sugg%c3%a9r%c3%a9e-2)

Analyse amortie [#](#analyse-amortie)
-------------------------------------

L’analyse amortie est une méthode utilisée pour évaluer la complexité moyenne d’une séquence d’opérations sur une structure de données, même si certaines opérations individuelles peuvent être coûteuses. Plutôt que de se concentrer sur le pire cas d’une seule opération, l’analyse amortie considère le coût total de nombreuses opérations et le répartit uniformément, offrant ainsi une vision plus réaliste de la performance globale. Le tri rapide (quick sort) est un algorithme qui a techniquement une complexité \\( O(n^2) \\), mais qui a une complexité amortie de \\( O(n \\log n) \\). En d’autres termes, le tri rapide est généralement rapide, mais il existe des cas rares où il est lent.

Vidéo optionnelle [#](#vid%c3%a9o-optionnelle)
----------------------------------------------

 [![Previous](/inf1220-hugo/svg/backward.svg "Les problèmes difficiles") Les problèmes difficiles](/inf1220-hugo/docs/modules/module1/difficile/) [Les erreurs communes ![Next](/inf1220-hugo/svg/forward.svg "Les erreurs communes")](/inf1220-hugo/docs/modules/module1/erreurs/) 

(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()

*   *   [Notation grand-O](#notation-grand-o)
    *   [Notation grand-O](#notation-grand-o-1)
    *   [Exemples d’algorithmes en](#exemples-dalgorithmes-en)
    *   [Exemples d’algorithmes en](#exemples-dalgorithmes-en-1)
    *   [Recherche dans un tableau trié](#recherche-dans-un-tableau-trié)
    *   [Tri](#tri)
    *   [Table de hachage](#table-de-hachage)
    *   [Un problème résoluble en ou en](#un-problème-résoluble-en--ou-en)
    *   [Les arbres en informatique](#les-arbres-en-informatique)
*   [Analyse amortie](#analyse-amortie)
*   [Vidéo optionnelle](#vidéo-optionnelle)