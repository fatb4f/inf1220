Les algorithmes: les structures de contrôle | INF 1220 - Introduction à la programmation 

[![Logo](/inf1220-hugo/livre.jpg)INF 1220 - Introduction à la programmation](/inf1220-hugo/)
--------------------------------------------------------------------------------------------

document.querySelector(".book-search").classList.remove("hidden")

*   [Programmation Java en ligne](/inf1220-hugo/docs/environnement/)
*   [Formattage du code Java](/inf1220-hugo/docs/format/)
*   [Vous avez trouvé une erreur?](/inf1220-hugo/docs/erreurs/)
*   [Modules](/inf1220-hugo/docs/modules/)
    *    [Module 1: Algorithme et pseudocode](/inf1220-hugo/docs/modules/module1/)
        *   [Modèle du cours](/inf1220-hugo/docs/modules/module1/teluq/)
        *   [Robot conversationnel et intelligence artificielle](/inf1220-hugo/docs/modules/module1/robot/)
        *   [Autoévaluation](/inf1220-hugo/docs/modules/module1/autoevaluation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module1/pasapas/)
        *   [Les ordinateurs et leurs langages](/inf1220-hugo/docs/modules/module1/ordinateurs/)
        *   [Les algorithmes](/inf1220-hugo/docs/modules/module1/algorithmes/)
        *   [Les algorithmes : conception et syntaxe](/inf1220-hugo/docs/modules/module1/algorithmes2/)
        *   [Les algorithmes: les structures de contrôle](/inf1220-hugo/docs/modules/module1/algorithmes3/)
        *   [Les problèmes difficiles](/inf1220-hugo/docs/modules/module1/difficile/)
        *   [Complexité algorithmique](/inf1220-hugo/docs/modules/module1/complex/)
        *   [Les erreurs communes](/inf1220-hugo/docs/modules/module1/erreurs/)
        *   [Présentation du pseudocode](/inf1220-hugo/docs/modules/module1/syntaxe/)
        *   [Exercices sur les algorithmes](/inf1220-hugo/docs/modules/module1/exercices/)
        *   [Travail noté 1](/inf1220-hugo/docs/modules/module1/travail-note-1/)
    *    [Module 2: Introduction au langage Java](/inf1220-hugo/docs/modules/module2/)
        *   [Préparation de l’espace de travail](/inf1220-hugo/docs/modules/module2/preparation/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module2/pasapas/)
        *   [Création d'une classe en Java](/inf1220-hugo/docs/modules/module2/oriente/)
        *   [Introduction aux types de base et à leurs opérateurs](/inf1220-hugo/docs/modules/module2/typeoperateur/)
        *   [Exercices sur les classes, les variables, les types et les opérateurs](/inf1220-hugo/docs/modules/module2/exercices-2-1/)
        *   [Méthodes et constructeurs](/inf1220-hugo/docs/modules/module2/methodes/)
        *   [Exercices sur les classes et méthodes](/inf1220-hugo/docs/modules/module2/exercices-2-2/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module2/conseils/)
        *   [MarkDown](/inf1220-hugo/docs/modules/module2/markdown/)
        *   [Gabarit pour les travaux notés 2, 3, 4 et 5](/inf1220-hugo/docs/modules/module2/gabarit/)
        *   [Travail noté 2](/inf1220-hugo/docs/modules/module2/travail-note-2/)
    *    [Module 3: Les structures de données, de contrôle et d'itération en Java](/inf1220-hugo/docs/modules/module3/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module3/pasapas/)
        *   [GitHub](/inf1220-hugo/docs/modules/module3/github/)
        *   [Les structures de contrôle](/inf1220-hugo/docs/modules/module3/activite-3-1/)
        *   [Les structures itératives](/inf1220-hugo/docs/modules/module3/activite-3-2/)
        *   [Les chaînes de caractères (String)](/inf1220-hugo/docs/modules/module3/activite-3-3-string/)
        *   [Les structures de données de base](/inf1220-hugo/docs/modules/module3/activite-3-3/)
        *   [Les valeurs aléatoires](/inf1220-hugo/docs/modules/module3/activite-3-3-random/)
        *   [La programmation fonctionnelle en Java](/inf1220-hugo/docs/modules/module3/fonctionnel/)
        *   [Exercices sur les structures de contrôle, les structures de données, les structures itératives](/inf1220-hugo/docs/modules/module3/exercices-3-1/)
        *   [Les exceptions](/inf1220-hugo/docs/modules/module3/activite-3-4/)
        *   [La récursivité](/inf1220-hugo/docs/modules/module3/activite-3-5/)
        *   [Exercices sur les exceptions et la récursivité](/inf1220-hugo/docs/modules/module3/exercices-3-2/)
        *   [Exemple : modèle de langue](/inf1220-hugo/docs/modules/module3/activite-3-3-modele/)
        *   [Recommandations](/inf1220-hugo/docs/modules/module3/conseils/)
        *   [Travail noté 3](/inf1220-hugo/docs/modules/module3/travail-note-3/)
    *    [Module 4: Les entrées et sorties](/inf1220-hugo/docs/modules/module4/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module4/pasapas/)
        *   [Les flux de console](/inf1220-hugo/docs/modules/module4/activite-4-1/)
        *   [Les flux de données: lecture dans des fichiers et autres](/inf1220-hugo/docs/modules/module4/activite-4-2/)
        *   [Exercices sur les flux](/inf1220-hugo/docs/modules/module4/exercices-4-1/)
        *   [Développement web](/inf1220-hugo/docs/modules/module4/web/)
        *   [Travail noté 4](/inf1220-hugo/docs/modules/module4/travail-note-4/)
    *    [Module 5. La programmation orientée objet: héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/)
        *   [Java pas à pas](/inf1220-hugo/docs/modules/module5/pasapas/)
        *   [L'héritage, les classes abstraites et les interfaces](/inf1220-hugo/docs/modules/module5/activite-5-1/)
        *   [Le polymorphisme](/inf1220-hugo/docs/modules/module5/activite-5-2/)
        *   [Exercices sur l’héritage et le polymorphisme](/inf1220-hugo/docs/modules/module5/exercices-5-1/)
        *   [Travail noté 5](/inf1220-hugo/docs/modules/module5/travail-note-5/)
    *   [Examen](/inf1220-hugo/docs/modules/examen/)
*   [Évaluation](/inf1220-hugo/docs/evaluation/)
*   [Pense-bête java](/inf1220-hugo/docs/pensebete/)
*    Autres ressources
    *   [Le professeur](/inf1220-hugo/docs/extra/credits/)
    *   [Feuille de route](/inf1220-hugo/docs/extra/feuille-de-route/)
    *   [Ressources](/inf1220-hugo/docs/extra/ressources/)
    *   [FAQ](/inf1220-hugo/docs/extra/faq/)
    *   [Manuel](/inf1220-hugo/docs/extra/manuel/)
    *   [Rappel mathématique](/inf1220-hugo/docs/extra/math/)
    *   [Intelligence artificielle](/inf1220-hugo/docs/extra/ia/)
    *   [Petit guide d’usage du courriel efficace](/inf1220-hugo/docs/extra/courriel/)

(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()

![Menu](/inf1220-hugo/svg/menu.svg)

### Les algorithmes: les structures de contrôle

![Table of Contents](/inf1220-hugo/svg/toc.svg)

*   [Le saut](#le-saut)
*   [L’embranchement comme structure de contrôle](#lembranchement-comme-structure-de-contrôle)
*   [La boucle comme structure de contrôle](#la-boucle-comme-structure-de-contrôle)
*   [Composition](#composition)
*   [La fin d’un algorithme](#la-fin-dun-algorithme)
*   [Exécution d’un pseudo-code](#exécution-dun-pseudo-code)
*   [Vidéo suggérée](#vidéo-suggérée)

Les structures de contrôle [#](#les-structures-de-contr%c3%b4le)
================================================================

Nous avons déjà présenté les notions d’embranchement et de boucle. C’est ce que nous appelons des structures de contrôle. Il est essentiel d’en comprendre la fonction.

On peut concevoir un algorithme qui ne comprend qu’une liste d’opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d’éléments, et on risque de devoir répéter beaucoup d’opérations. Les structures de contrôle permettent à l’algorithme de faire des choix de traitement en fonction de conditions. Une structure de contrôle correspond à l’action de tester des variables de contrôle et selon les résultats d’effectuer des opérations ou non.

Le saut [#](#le-saut)
---------------------

Le saut est une structure de contrôle fondamentale en informatique qui permet de modifier le flux d’exécution d’un algorithme en redirigeant l’exécution vers une autre partie du programme. Contrairement aux structures comme les embranchements (qui choisissent entre plusieurs chemins selon une condition) ou les boucles (qui répètent un bloc d’instructions), le saut est une instruction explicite qui transfère immédiatement le contrôle à une position spécifique dans le code, souvent marquée par une étiquette ou une adresse. Un saut peut être inconditionnel, où l’exécution est toujours redirigée vers une nouvelle position, ou conditionnel, où le saut dépend d’une condition booléenne.

Un saut inconditionnel redirige l’exécution vers une étiquette ou une ligne spécifique sans vérifier de condition. En pseudo-code, cela peut être représenté ainsi :

    ÉTIQUETTE debut
    écrire "Bonjour"
    SAUTER À debut
    

Dans cet exemple, l’algorithme affiche “Bonjour” et saute immédiatement à l’étiquette debut, créant une boucle infinie. Bien que rarement utilisé seul en pseudo-code, ce type de saut est courant dans les langages de bas niveau pour organiser le flux du programme

L’embranchement comme structure de contrôle [#](#lembranchement-comme-structure-de-contr%c3%b4le)
-------------------------------------------------------------------------------------------------

Un saut conditionnel (ou embranchement) dépend d’une condition booléenne. Si la condition est vraie, l’exécution saute à une étiquette donnée ; sinon, elle continue séquentiellement. Voici un exemple en pseudo-code :

    lire nombre
    SI nombre < 0 ALORS
        SAUTER À negatif
    FIN SI
    écrire "Le nombre est positif ou nul"
    SAUTER À fin
    ÉTIQUETTE negatif
    écrire "Le nombre est négatif"
    ÉTIQUETTE fin
    

En pratique, ces structures correspondent à poser des questions avec la syntaxe suivante : SI conditions ALORS opérations FIN SI. Il peut y avoir plusieurs conditions dans une structure de contrôle et la logique booléenne est utilisée pour les construire. Par exemple, SI a est égal 0 ET b est égal 1 ALORS faire c FIN SI.

Dans la notion de pseudo-code, il est également possible de faire une suite de structures de contrôle avec la syntaxe suivante : SI conditionA ALORS opérations SINON SI conditionB ALORS opérations SINON SI conditionC ALORS \[et ainsi de suite\] FIN SI.

Voici un exemple en pseudo-code illustrant une suite de structures de contrôle avec plusieurs conditions pour classer un score obtenu à un examen :

    lire score
    SI score ≥ 90 ALORS
        écrire "Note : A"
    SINON SI score ≥ 80 ALORS
        écrire "Note : B"
    SINON SI score ≥ 70 ALORS
        écrire "Note : C"
    SINON SI score ≥ 60 ALORS
        écrire "Note : D"
    SINON
        écrire "Note : F"
    FIN SI
    

Dans cet exemple, l’algorithme lit une variable score (un nombre entier représentant un score d’examen). Il utilise une série de conditions pour déterminer la note correspondante :

*   Si score est supérieur ou égal à 90, la note est “A”.
*   Sinon, si score est supérieur ou égal à 80, la note est “B”.
*   Sinon, si score est supérieur ou égal à 70, la note est “C”.
*   Sinon, si score est supérieur ou égal à 60, la note est “D”.
*   Sinon (pour tout score inférieur à 60), la note est “F”.

Chaque condition est évaluée séquentiellement, et dès qu’une condition est vraie, l’algorithme exécute l’opération associée (afficher la note) et sort de la structure avec FIN SI. Si aucune condition n’est vraie, l’opération par défaut (afficher “Note : F”) est exécutée.

Considérons l’exemple suivant. Il s’agit d’un outil interactif qui t’aide à comprendre comment un algorithme utilise des conditions pour classer une personne selon son âge. Pour commencer, saisis un âge entier positif dans le champ prévu, par exemple « 25 ». Ensuite, clique sur « Prochaine étape » pour exécuter l’algorithme étape par étape. À chaque clic, une ligne du pseudocode s’illumine, et un message explicatif apparaît dans la zone de journalisation en bas. Tu verras également l’état mis à jour : l’âge saisi et la catégorie déterminée (comme « Vous êtes un adulte »). Si tu veux recommencer, clique sur « Réinitialiser » pour effacer les résultats. Attention, l’âge doit être un nombre entier positif, sinon un message te demandera de corriger.

Cet outil vous permet de suivre le raisonnement de l’algorithme de manière claire. Le pseudocode, affiché à gauche, utilise une structure conditionnelle (SI, SINON SI, SINON) pour évaluer l’âge et assigner une catégorie : enfant (≤ 10 ans), adolescent (> 10 et < 18 ans), adulte (≥ 18 et < 65 ans) ou personne âgée (≥ 65 ans). En progressant dans les étapes, observe comment l’algorithme teste chaque condition et choisit la bonne catégorie. Lisez attentivement les messages du journal pour comprendre les décisions prises.

Catégorie d'âge
===============

Entrez un âge et exécutez le pseudocode pour déterminer la catégorie d'âge.

Pseudocode

État

Âge : 0

Sortie : \-

Prochaine étape Réinitialiser

(function(){for(var t=document.currentScript.previousElementSibling;t&&!t.classList.contains("age-app");)t=t.previousElementSibling;if(!t)return;let n=0,o="-",e=0,i=!1;const r=\["SI age <= 10 ALORS",\` Imprimer à l'écran "Vous êtes un enfant"\`,"SINON SI age > 10 ET age < 18 ALORS",\` Imprimer à l'écran "Vous êtes un adolescent"\`,"SINON SI age >= 18 ET age < 65 ALORS",\` Imprimer à l'écran "Vous êtes un adulte"\`,"SINON",\` Imprimer à l'écran "Vous êtes une personne âgée"\`,"FIN SI"\];function a(){t.querySelector(".ageAge").textContent=n,t.querySelector(".ageOutput").textContent=o;const s=t.querySelector(".agePseudocode");s.innerHTML=r.map((t,n)=>\`<span style="display: block; ${n===e?"background: #e6f4ea; color: #15803d;":""}">${t}</span>\`).join(""),t.querySelector(".ageStepButton").style.cssText=i||e>=r.length?"background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: not-allowed; font-size: 16px;":"background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;"}function s(e){const s=t.querySelector(".ageLog"),n=document.createElement("div");n.textContent=e,n.style.cssText="opacity: 0; transition: opacity 0.5s ease;",s.appendChild(n),setTimeout(()=>{n.style.opacity="1"},10),s.scrollTop=s.scrollHeight}function d(e){const t=Number(e);return!isNaN(t)&&Number.isInteger(t)&&t>=0}function c(){const e=t.querySelector(".ageAgeInput").value;return d(e)?(n=Number(e),l(),!0):(alert("Veuillez entrer un âge entier positif."),t.querySelector(".ageAgeInput").value=n||25,!1)}async function u(){if(i||e>=r.length)return;i=!0,t.querySelector(".ageStepButton").style.cssText="background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: not-allowed; font-size: 16px;",e===0?(n=Number(t.querySelector(".ageAgeInput").value),s(\`Vérification : age = ${n} <= 10\`),n<=10?e=1:e=2):e===1?(o="Vous êtes un enfant",s('Affichage : "Vous êtes un enfant"'),e=8):e===2?(s(\`Vérification : age = ${n} > 10 et age < 18\`),n>10&&n<18?e=3:e=4):e===3?(o="Vous êtes un adolescent",s('Affichage : "Vous êtes un adolescent"'),e=8):e===4?(s(\`Vérification : age = ${n} >= 18 et age < 65\`),n>=18&&n<65?e=5:e=6):e===5?(o="Vous êtes un adulte",s('Affichage : "Vous êtes un adulte"'),e=8):e===6?(s(\`Condition : SINON (aucune condition précédente n’est vraie)\`),e=7):e===7?(o="Vous êtes une personne âgée",s('Affichage : "Vous êtes une personne âgée"'),e=8):e===8&&(s(\`Fin de l’exécution : résultat = "${o}"\`),e++),a(),await new Promise(e=>setTimeout(e,500)),i=!1,a()}function l(){n=Number(t.querySelector(".ageAgeInput").value)||25,o="-",e=0,t.querySelector(".ageLog").innerHTML="",a()}t.querySelector(".ageAgeInput").addEventListener("change",c),t.querySelector(".ageStepButton").addEventListener("click",u),t.querySelector(".ageResetButton").addEventListener("click",function(){c()&&l()}),a()})()

Après avoir utilisé l’outil, prenez un moment pour réfléchir à la flexibilité de cet algorithme. Comment pourriez-vous le modifier pour ajouter de nouvelles catégories, comme « bébé » pour les âges de 0 à 2 ans, ou pour inclure des critères supplémentaires, comme une distinction entre « jeune adulte » et « adulte senior » ? Que se passerait-il si l’âge pouvait être négatif ou non entier ? Comment adapteriez-vous le pseudocode pour gérer ces cas ?

La boucle comme structure de contrôle [#](#la-boucle-comme-structure-de-contr%c3%b4le)
--------------------------------------------------------------------------------------

Il arrive régulièrement dans la résolution d’un problème qu’il est nécessaire de réaliser à plusieurs reprises une ou des opérations sur un ensemble de données. Par exemple, supposons qu’il est nécessaire de trouver le plus petit nombre dans un tableau d’entiers. Il sera forcément nécessaire d’itérer dans le tableau, une ligne à la fois, et de comparer les nombres entre eux. Pour ce faire, nous utiliserons deux éléments de syntaxe, soit le TANT QUE \_ FAIRE ou bien le POUR TOUT \_ FAIRE. Voici deux exemples de l’utilisation de ces deux approches :

Pseudocode 1 : Boucle POUR TOUT

    Entrées :
    Tableau d'entiers : tableau[100]
    
    Sorties :
    Entier minimum
    
    minimum = tableau[0]
    POUR TOUT Entier e de tableau FAIRE
        SI e < minimum ALORS
            minimum = e;
        FIN SI
    FIN POUR TOUT
    

Ce pseudocode décrit un algorithme pour trouver la valeur minimale dans un tableau d’entiers de taille 100. L’algorithme commence par initialiser la variable minimum à la première valeur du tableau (tableau\[0\]), en supposant que le tableau n’est pas vide. Ensuite, une boucle (POUR TOUT Entier e de tableau FAIRE) parcourt chaque élément e du tableau. À chaque itération, si l’élément e est inférieur à la valeur actuelle de minimum, alors minimum est mis à jour avec la valeur de e (minimum = e). À la fin de la boucle, minimum contient la plus petite valeur du tableau, qui est retournée comme résultat.

Pseudocode 2 : Boucle TANT QUE

    Entrées :
    Tableau d'entiers : tableau[100]
    
    Sorties :
    Entier minimum
    
    minimum = tableau[0]
    Entier iterateur = 0;
    TANT QUE iterateur < 100 FAIRE
        SI tableau[iterateur] < minimum ALORS
            minimum = tableau[iterateur];
        FIN SI
        iterateur = iterateur + 1;
    FIN TANT QUE
    

Ce pseudocode décrit un algorithme pour trouver la valeur minimale dans un tableau d’entiers de taille 100. Une variable minimum est initialisée avec la première valeur du tableau (tableau\[0\]), supposant que le tableau n’est pas vide. Une variable iterateur est initialisée à 0 pour suivre la position dans le tableau. La boucle (TANT QUE iterateur < 100 FAIRE) parcourt le tableau tant que iterateur est inférieur à 100. À chaque itération, si l’élément à l’indice iterateur (tableau\[iterateur\]) est inférieur à minimum, alors minimum est mis à jour avec cette valeur. Ensuite, iterateur est incrémenté de 1 (iterateur = iterateur + 1) pour passer à l’élément suivant. À la fin de la boucle, minimum contient la plus petite valeur du tableau, qui est retournée.

Au niveau fondamental, une boucle peut être vue comme un saut conditionnel dans le flux d’exécution d’un algorithme. Un saut conditionnel est une instruction qui, en fonction d’une condition, redirige l’exécution vers une autre partie du programme. Dans le cas d’une boucle, ce saut ramène l’exécution au début du bloc d’instructions tant que la condition associée à la boucle reste vraie.

Prenons l’exemple de la boucle TANT QUE. La condition iterateur < 100 est évaluée à chaque itération. Si elle est vraie, l’algorithme exécute le corps de la boucle (comparaison et mise à jour de minimum, incrémentation de iterateur), puis retourne au début de la boucle pour réévaluer la condition. Ce retour au début est un saut conditionnel : l’algorithme “saute” en arrière dans le code pour répéter le processus. Lorsque la condition devient fausse (quand iterateur atteint 100), le saut n’a plus lieu, et l’exécution continue après la boucle.

De même, dans la boucle POUR TOUT du Pseudocode 1, bien que la syntaxe soit plus abstraite, le mécanisme sous-jacent est similaire. La boucle parcourt chaque élément du tableau, ce qui peut être traduit en une série de sauts conditionnels gérés implicitement : après avoir traité un élément, l’algorithme “saute” à l’élément suivant tant qu’il reste des éléments à traiter.

Composition [#](#composition)
-----------------------------

Dans la pratique, un algorithme peut comporter plusieurs structures de contrôle itératives, plusieurs structures de contrôle alternatives et plusieurs opérations. On peut les combiner de diverses manières. Il est possible, par exemple, d’avoir une boucle TANT QUE au sein d’une autre boucle TANT QUE.

    TANT QUE x > 0 FAIRE
      TANT QUE x > 10 FAIRE
         x = x - 1
      FIN TANT QUE
    FIN TANT QUE
    

Ce pseudocode décrit une structure de boucles imbriquées qui modifie la valeur de la variable x jusqu’à ce qu’elle devienne inférieure ou égale à 0. La boucle externe (TANT QUE x > 0 FAIRE) continue tant que x est strictement positif. À l’intérieur, la boucle interne (TANT QUE x > 10 FAIRE) s’exécute uniquement si x est supérieur à 10, et dans ce cas, elle décrémente x de 1 à chaque itération (x = x - 1). Une fois que x devient inférieur ou égal à 10, la boucle interne s’arrête, mais la boucle externe ne se termine pas immédiatement, car elle vérifie seulement si x > 0. Cependant, comme il n’y a aucune instruction dans la boucle externe pour modifier x lorsque x ≤ 10, le programme entre dans une boucle infinie si x est compris entre 1 et 10 inclus. Si x est initialement supérieur à 10, il sera décrémenté jusqu’à atteindre 10, puis le programme se bloquera. Si x est initialement inférieur ou égal à 0, aucune des boucles ne s’exécute.

La fin d’un algorithme [#](#la-fin-dun-algorithme)
--------------------------------------------------

Un algorithme continue à s’exécuter tant qu’il reste des operations à faire. L’algorithme prend fin lorsque nous rencontrons la fin du pseudo-code ou lorsque le programmeur invoque la fin spécifiquement. Dans l’exemple suivant, le programmeur demande à ce que l’on cesse l’exécution dès que la valeur 5 est rencontrée.

    x = 0
    TANT QUE x < 10 ALORS
       ajoute un à x
       SI x == 5 ALORS TERMINE
    FIN TANT QUE
    AFFICHE x
    

La valeur x ne sera donc jamais affichée.

Il arrive aussi qu’un pseudo-code doit retourner une valeur. Par convention, dès que la valeur attendue est retournée, l’algorithme prend fin. Ainsi donc, dans le cas suivant, la valeur 5 sera retournée.

    x = 0
    TANT QUE x < 10 ALORS
       ajoute un à x
       SI x == 5 ALORS RETOURNE x
    FIN TANT QUE
    RETOURNE x
    

Exécution d’un pseudo-code [#](#ex%c3%a9cution-dun-pseudo-code)
---------------------------------------------------------------

Pour comprendre un pseudo-code que vous venez de recevoir, ou pour tester un pseudo-code que vous venez de créer, il est essentiel de l’exécuter. Quand on exécute un pseudo-code, on se contente de lire les consignes logiques.

Prenons un exemple:

    Variable test = 0
    
    TANT QUE test < 100
      test = test + 22
    FIN TANT QUE
    
    retourne test
    

mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})

graph TD
    A\[Début\] --> B\[Initialiser test = 0\]
    B --> C{test < 100 ?}
    C -- Vrai --> D\[test = test + 22\]
    D --> C
    C -- Faux --> E\[Retourner test\]
    E --> F\[Fin\]

1.  Je débute le pseudo-code avec la valeur 0 stockée dans la variable test.
2.  J’entre dans la boucle TANT QUE.
3.  J’ajoute 22 à la variable test, le résultat est 22.
4.  J’entre dans la boucle TANT QUE.
5.  J’ajoute 22 à la variable test, le résultat est 44.
6.  J’entre dans la boucle TANT QUE.
7.  J’ajoute 22 à la variable test, le résultat est 66.
8.  J’entre dans la boucle TANT QUE.
9.  J’ajoute 22 à la variable test, le résultat est 88.
10.  J’entre dans la boucle TANT QUE.
11.  J’ajoute 22 à la variable test, le résultat est 110.
12.  Je quitte la boucle TANT QUE.
13.  Je retourne la valeur stockée dans la variable test, soit 110.

Vous devez absolument être capable de faire de telles exécutions. Dans certains cas, votre pseudo-code va dépendre de paramètres: il faut alors exécuter le pseudo-code plus d’une fois, sur plusieurs cas de test. Dans certains cas, le pseudo-code peut prendre trop d’étapes pour qu’un humain puisse l’exécuter entièrement : vous devriez au moins en faire une partie.

Vidéo suggérée [#](#vid%c3%a9o-sugg%c3%a9r%c3%a9e)
--------------------------------------------------

 [![Previous](/inf1220-hugo/svg/backward.svg "Les algorithmes : conception et syntaxe") Les algorithmes : conception et syntaxe](/inf1220-hugo/docs/modules/module1/algorithmes2/) [Les problèmes difficiles ![Next](/inf1220-hugo/svg/forward.svg "Les problèmes difficiles")](/inf1220-hugo/docs/modules/module1/difficile/) 

(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()

*   [Le saut](#le-saut)
*   [L’embranchement comme structure de contrôle](#lembranchement-comme-structure-de-contrôle)
*   [La boucle comme structure de contrôle](#la-boucle-comme-structure-de-contrôle)
*   [Composition](#composition)
*   [La fin d’un algorithme](#la-fin-dun-algorithme)
*   [Exécution d’un pseudo-code](#exécution-dun-pseudo-code)
*   [Vidéo suggérée](#vidéo-suggérée)